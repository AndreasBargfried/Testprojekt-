SUB main()
 'CALL CreateCenter()
 'CALL SimpleConnect("adressen")
 'CALL CreateLoadSend("formular")
 'CALL FilialeToCenter("d:\afm.tst\",0, - 1)
 CALL CenterToFiliale("d:\afm.tst\",1,0)

 END SUB 
 

SUB PROVPPCS()
 END SUB 
 '*********************************************************************************************** 
 

SUB main()
 'REGISTER CLEAR 
 'REGISTER "USER","MessageBox","IICCI"
 'CALL AbgPlausi("plausi.txt")
 
     'DIRECTORY "d:\ppcsabgl\hiera"
     'LOAD "HIERA", APPEND 
     'IF CopyRecord%("adrsend","adressen") <> - 1 REQUEST ""
     'CALL SimpleConnect("connect")
     'CALL AbgleichInit()
     'IF Send%() = - 1 THEN REQUEST "supa"
     'CALL ManiSer("Adressen", 5000)
     'CALL test()
     'CALL DeleteAll()
     'CALL DeleteCenter()
 
     'CALL SimpleConnect("akquise")
     CALL SimpleConnect("maadr")
  
     'CALL ForceLoad("adressen")
     'CALL ForceLoad("telefon")
 
        'CALL CryptPwd("d:\dkm\temp")
        'CALL PPCSOpenTest2()
        'CALL PrintPPCSOpen("times2.txt")
        'CALL PPCSSuchTest()
 
 END SUB 
 '***********************************************************************************************
 
 
SUB PPCSOpenTest()
 'îffnet alle Dateien vom Typ "A" Åber PPCS und protokolliert die Dauer fÅr 
 'diesen Vorgang in die Datei PPCSTime
 
    CLOSE ALL 
    IF NOT OPEN ("AbgFiles") THEN 
        OPEN FILE SHARE ,1jaPPCSPath$ + "abgfiles;paris"
    END IF 
    typ$ = "P"' C - VerschlÅsselt, P - Zugriffs-pwd
    leervoll$ = "L"
    rep% = 20' wie oft soll geîffnet werden (direkt nacheinander)
    DIM Values%(rep%)
 
    ip$ = "130.50.0.203"
    port$ = "1280"
    udpserver$ = ip$ + ":" + port$
    Connections.Clear()
    IF NOT Connections.Exists("CODIE") = - 1 THEN 
        Connections.Add("CODIE","ConnectionUDPClient").ServerName = udpserver$
        Superbase.Connections.CODIE.Timeout = 8000
    END IF 
 
    SELECT FIRST FILE "abgfiles" INDEX CodeFile.AbgFiles
    WHILE NOT EOF ("AbgFiles")
        '
        IF Typ.AbgFiles = "A" OR Typ.AbgFiles = "C" OR Typ.AbgFiles = "Z" THEN 
            datei$ = FileName.AbgFiles
            SET STATUS datei$
            'CALL Fehler("PPCSOpen","Datei: " + datei$)
 
            FOR z% = 1 TO rep%
 
                tBefore% = Superbase.Now
                OPEN FILE SHARE ,1"CODIE:" + datei$ + ";paris"
                tAfter% = Superbase.Now
 
                Values%(z%) = tAfter% - tBefore%
                average% = average% + (tAfter% - tBefore%)
 
                IF OPEN (datei$) THEN CLOSE FILE datei$
 
            NEXT z%
            average% = average% / rep%
 
            'mittleres Abstandsquadrat berechnen
            square% = 0
            FOR z% = 1 TO rep%
                square% = square% + (average% - Values%(z%)) * (average% - Values%(z%))
            NEXT z%
            square% = SQR (square%) / rep%
 
 
            'Ergebnis wegschreiben
            SELECT CURRENT LOCK FILE "AbgFiles" INDEX CodeFile.AbgFiles
                
                Square.AbgFiles = square%
                IF typ$ = "C" AND leervoll$ = "L" THEN 
                    TimeC_L.AbgFiles = average%
                END IF 
                IF typ$ = "P" AND leervoll$ = "L" THEN 
                    TimeP_L.AbgFiles = average%
                END IF 
                IF typ$ = "C" AND leervoll$ = "V" THEN 
                    TimeC.AbgFiles = average%
                END IF 
                IF typ$ = "P" AND leervoll$ = "V" THEN 
                    TimeP.AbgFiles = average%
                END IF 
                
 
            STORE FILE "AbgFiles"
 
        END IF 
 
        SELECT NEXT FILE "abgfiles" INDEX CodeFile.AbgFiles
    WEND 
 
 END SUB 
 '***********************************************************************************************  
  
 
SUB PPCSOpenTest2()
 'îffnet alle Dateien vom Typ "A" Åber PPCS und protokolliert die Dauer fÅr 
 'diesen Vorgang in die Datei PPCSTime
 
    CLOSE ALL 
    IF NOT OPEN ("AbgFiles") THEN 
        OPEN FILE SHARE ,1jaPPCSPath$ + "abgfiles;paris"
    END IF 
 
    leervoll$ = "L"
    rep% = 20' wie oft soll geîffnet werden (direkt nacheinander)    
 
    ip$ = "130.50.0.203"
    port$ = "1280"
    udpserver$ = ip$ + ":" + port$
 
 
    FOR z% = 1 TO rep%
        
        CLOSE ALL 
        IF NOT OPEN ("AbgFiles") THEN 
            OPEN FILE SHARE ,1jaPPCSPath$ + "abgfiles;paris"
        END IF 

        REQUEST "Loop: " + STR$ (z%,"z")
        Connections.Clear()
        IF NOT Connections.Exists("CODIE") = - 1 THEN 
            Connections.Add("CODIE","ConnectionUDPClient").ServerName = udpserver$
            Superbase.Connections.CODIE.Timeout = 8000
        END IF 

        SELECT FIRST FILE "abgfiles" INDEX CodeFile.AbgFiles
        WHILE NOT EOF ("AbgFiles")
        '            
            IF Typ.AbgFiles = "A" OR Typ.AbgFiles = "C" OR Typ.AbgFiles = "Z" THEN 
                datei$ = FileName.AbgFiles
                SET STATUS datei$
                'CALL Fehler("PPCSOpen2","Datei: " + datei$)
 
                tBefore% = Superbase.Now
                OPEN FILE SHARE ,1"CODIE:" + datei$ + ";paris"
                tAfter% = Superbase.Now
 
                IF OPEN (datei$) THEN CLOSE FILE datei$
 
                'kummulierende Summe wegschreiben
                SELECT CURRENT LOCK FILE "AbgFiles" INDEX CodeFile.AbgFiles
                    IF (z% = 1) THEN 
                        IF leervoll$ = "L" THEN 
                            Time_L.AbgFiles = 0
                        END IF 
                        IF leervoll$ = "V" THEN 
                            Time.AbgFiles = 0
                        END IF 
                    END IF 
                                
                    IF leervoll$ = "L" THEN 
                        Time_L.AbgFiles = Time_L.AbgFiles + (tAfter% - tBefore%) / rep%
                    END IF 
                    IF leervoll$ = "V" THEN 
                        Time.AbgFiles = Time.AbgFiles + (tAfter% - tBefore%) / rep%
                    END IF 
  
                STORE FILE "AbgFiles"
                UNLOCK CURRENT FILE "AbgFiles"
            END IF 
 
            SELECT NEXT FILE "abgfiles" INDEX CodeFile.AbgFiles
        WEND 

    NEXT z%

 END SUB 
 '***********************************************************************************************  
 

SUB PrintPPCSOpen(txtfile$)
    sep$ = ";"
    OPEN txtfile$ FOR OUTPUT 
    SELECT FIRST FILE "abgfiles" INDEX CodeFile.AbgFiles
    'Header schreiben
    ? "FileName" + sep$ + "FieldCount" + sep$ + "IndexCount" + sep$ + "TXT1000Count" + sep$;
    ? "Time" + sep$ + "Time_L"
    WHILE NOT EOF ("AbgFiles")
        
        IF Typ.AbgFiles = "A" OR Typ.AbgFiles = "C" OR Typ.AbgFiles = "Z" THEN 
            ? FileName.AbgFiles + sep$;
            ? STR$ (FieldCount.AbgFiles,"z") + sep$;
            ? STR$ (IndexCount.AbgFiles,"z") + sep$;
            IF TXT1000Count.AbgFiles = 0 THEN 
                ? "0" + sep$;
            ELSE 
                ? STR$ (TXT1000Count.AbgFiles,"z") + sep$;
            END IF 
            ? STR$ (Time.AbgFiles,"0000") + sep$;
            ? STR$ (Time_L.AbgFiles,"0000")
        END IF 
 
        SELECT NEXT FILE "abgfiles" INDEX CodeFile.AbgFiles
    WEND 
    ? ""
 
    CLOSE OUTPUT 
 END SUB 
 '***********************************************************************************************  
 

SUB Fehler(Z1$,Z2$)
 msg$ = Z1$
 IF z2$ <> "" THEN msg$ = msg$ + CHR$ (13) + CHR$ (10) + Z2$
 v% = CALL ("MessageBox",hWnd%%, FN ansi(msg$), FN ansi(title$),48)
 END SUB 
 '***********************************************************************************************
 

SUB ForceLoad(datei$,wks%)
  
    'Dirty-Felder in der Zentrale neu setzen
    'wenn wks% <> -1 ==> nur die Daten dieser Filiale bekommen den Dirty-Zustand
    'nach AusfÅhrung der Funktion werden alle Daten von den Filialen
    'beim nÑchsten CenterToLoad Åbernommen
    'Vor.: datei$ und AbgFiles mÅssen geîffnet sein
    oldErrorLabel$ = Superbase.ErrorTrapLabel
 
        wks$ = "Workstation." + datei$
        code$ = GetFileCode$(datei$)
        code$ = code$ + "." + datei$
    IF wks% = - 1 THEN 
 
        SELECT FIRST FILE datei$ INDEX code$$
        WHILE NOT EOF (datei$)
            ON ERROR GOTO ForceNextError1
            SELECT CURRENT LOCK FILE datei$ INDEX code$$
            recfield$ = "rec0." + datei$
            recfield$$ = wks$$
            FOR i% = 1 TO 19
                recfield$ = "rec" + STR$ (i%,"z") + "." + datei$
                recfield$$ = wks$$
            NEXT i%
  
            STORE FILE datei$
            UNLOCK CURRENT FILE datei$
            'alles io
            GOTO ForceNext2

ForceNextError1: 
            IF jaDebug% = - 1 THEN CALL Fehler("Fehler in ForceLoad: " + datei$, STR$ ( ERRNO ,"z") + ": " + ERR$ ( ERRNO ))

ForceNext1: 
            ON ERROR GOTO ErrorHandler
            SELECT NEXT FILE datei$ INDEX code$$
        WEND 
    ELSE 
        
        SELECT FIRST FILE datei$ INDEX wks$$
        SELECT KEY wks% FILE datei$ INDEX wks$$
        WHILE NOT EOF (datei$) AND wks$$ = wks%
            ON ERROR GOTO ForceNextError2
            SELECT CURRENT LOCK FILE datei$ INDEX wks$$
            recfield$ = "rec0." + datei$
            recfield$$ = wks$$
            FOR i% = 1 TO 19
                recfield$ = "rec" + STR$ (i%,"z") + "." + datei$
                recfield$$ = wks$$
            NEXT i%

            STORE FILE datei$
            UNLOCK CURRENT FILE datei$
            'alles io
            GOTO ForceNext2

ForceNextError2: 
            IF jaDebug% = - 1 THEN CALL Fehler("Fehler in ForceLoad: " + datei$, STR$ ( ERRNO ,"z") + ": " + ERR$ ( ERRNO ))
 
ForceNext2: 
            ON ERROR GOTO ErrorHandler
            SELECT NEXT FILE datei$ INDEX wks$
        WEND 
    END IF 

    Superbase.ErrorTrapLabel = oldErrorLabel$
 END SUB 
 '***********************************************************************************************   
 
 
SUB SetDisplay(typ%)
 'typ = -1 -> Standard-Fenster-Eigenschaften
 'typ = 0  -> Abgleich-Formular-Eigenschaften
 
 IF typ% = 0 THEN 

     'Abgleich-Formular zurechtbasteln
     SET MENU OFF 
     Superbase.MDIMode = 0
     Superbase.WindowState = 0
     Superbase.Sizeable = - 1
     Superbase.Top = 50
     Superbase.Left = 50
     Superbase.Width = 500
     Superbase.Height = 220
     Superbase.Sizeable = 0
     Superbase.SelectionBar = 0
     Superbase.StatusBar = 0
     Superbase.IconBarState = 0
     Superbase.BorderStyle = 1

     DIM w AS SDIWindow 
     SET w = Superbase.Windows(1)
     w.OpenForm(_netpath$ + "ppcsabgl")
     w.Form.FktL.Caption = " "
     w.Form.TitleL.Caption = " "
     w.Form.CounterL.Caption = " "
    SET DISPLAY ON 

 ELSE 

 
     Superbase.StatusBar = - 1
     ScrWidth% = FN sys(6)
     ScrHeight% = FN sys(7)
     CapHeight% = CALL ("GetSystemMetrics",4)
     REM CALL Fehler("Screen","")
     IF (ScrWidth% < 800 OR ScrHeight% < 600) AND ( UCASE$ (_projekt$) LIKE "FACTURA" OR UCASE$ (_projekt$) LIKE "AKTE" OR UCASE$ (_projekt$) LIKE "PROVIS" OR UCASE$ (_projekt$) LIKE "OFFICE") THEN 
          CALL Fehler("Sie kînnen das Programm nicht unter der Bildschirmauflîsung 640*480 betreiben!","éndern Sie bitte Ihre Bildschirmauflîsung in 800 * 600 (kleine Schrift/Small Fonts)!")
     ELSE 
          SELECT CASE ScrWidth%
          CASE 640
               LargeFont$ = "FALSE"
               IF UCASE$ (_projekt$) LIKE "FACTURA" OR UCASE$ (_projekt$) LIKE "AKTE" OR UCASE$ (_projekt$) LIKE "PROVIS" OR UCASE$ (_projekt$) LIKE "OFFICE" THEN 
                    CALL Fehler("Sie kînnen das Programm nicht unter der Bildschirmauflîsung 640*480 betreiben!","éndern Sie bitte Ihre Bildschirmauflîsung in 800 * 600 (kleine Schrift/Small Fonts)!")
                    REM CALL EXIT()
               END IF 
          CASE 800
               IF CapHeight% > 20 THEN LargeFont$ = "TRUE" ELSE LargeFont$ = "FALSE"
               IF LargeFont$ = "TRUE" THEN 
                    CALL Fehler("Siehe haben als Bildschirmfont ~Largefonts/Gro·e Schriftart~ eingestellt, dies fÅhrt zu Problemen, da die Programm-Masken fÅr Auflîsung 800*600 Kleine Schriftart erstellt wurden!","Bitte Ñndern Sie den Bildschirmfont!")
               END IF 
          CASE 1024
               IF CapHeight% > 20 THEN LargeFont$ = "TRUE" ELSE LargeFont$ = "FALSE"
          CASE 1152
               IF CapHeight% > 20 THEN LargeFont$ = "TRUE" ELSE LargeFont$ = "FALSE"
          CASE 1280
               IF CapHeight% > 20 THEN LargeFont$ = "TRUE" ELSE LargeFont$ = "FALSE"
          CASE 1600
               IF CapHeight% > 20 THEN LargeFont$ = "TRUE" ELSE LargeFont$ = "FALSE"
          END SELECT 
          REM 060499
          IF UCASE$ (LargeFont$) = "FALSE" THEN 
               WndWidth% = 640
               WndHeight% = 480
               IF UCASE$ (_projekt$) LIKE "FACTURA" OR UCASE$ (_projekt$) LIKE "AKTE" OR UCASE$ (_projekt$) LIKE "PROVIS" OR UCASE$ (_projekt$) LIKE "OFFICE" OR UCASE$ (_projekt$) LIKE "IMMAK" OR UCASE$ (_projekt$) LIKE "MEDIA" THEN 
                    WndWidth% = 800
                    WndHeight% = 600
               END IF 
          ELSE 
               SELECT CASE ScrWidth%
               CASE 640
                    WndWidth% = 640
                    WndHeight% = 480
               CASE 800
                    WndWidth% = 950
                    WndHeight% = 700
               CASE 1024
                    WndWidth% = 950
                    WndHeight% = 700
               CASE 1152
                    WndWidth% = 950
                    WndHeight% = 700
               CASE 1280
                    WndWidth% = 950
                    WndHeight% = 700
               CASE 1600
                    WndWidth% = 950
                    WndHeight% = 700
               END SELECT 
          END IF 
     END IF 
 
     _wpx% = ( FN sys(6) - WndWidth%) / 2
     _wpy% = ( FN sys(7) - WndHeight%) / 2
     SET POSITION _wpx%,_wpy%,WndWidth%,WndHeight%
     SET POSITION 
 END IF 
 DisplaySet% = 0
 END SUB 
  '***********************************************************************************************

  
SUB AbgleichInit()
     'Deklariert Globale Variablen, die fÅr den Abgleich und die Filial-Hierarchie benîtigt werden
     'ruft Funktion ReadHiera() auf, die die Hierarchie-Infos aus der FILIALE bzw. LFILIALE liest
     'baut im Online-Fall die LFILIALE neu auf
     'definiert im Offline-Fall die Workstation% aus der Ini
     'definiert jaDebug%


     oldErrorLabel$ = Superbase.ErrorTrapLabel
     GLOBAL jaDebug%
     jaDebug% = 0
  
     a$ = ReadConfig$("PROVIS","jaDEBUG")
     REM CALL Fehler(a$,"")
     IF a$ <> "0" AND a$ <> "leer" THEN 
          jaDebug% = - 1
     END IF 
 
     IF jaDebug% = - 1 THEN 
          CALL Fehler("AbgleichInit()","")
     END IF 
  
     'Konstanten fÅr Hierarchie-Modell
     REM GLOBAL Nachfolger%(0)'Array aller Filial-Nummern
     REM GLOBAL VorgÑnger%(0)'Array alller VorgÑnger-Filial-Nummern (korrespondierend zu Nachfolger%)
     GLOBAL OffNames$(0)'Array aller Filial-Namen (korresp. zu Nachfolger%)
     GLOBAL OffCount%'Anzahl BÅros der eigenen Hierarchie 
 
     'Sichtbare BÅros ermitteln
     GLOBAL VisOff%(0)'Array der sichtbaren Workstation-Nummern
     GLOBAL VisNames$(0)'Array der sichtbaren Workstation-Namen
     GLOBAL VisCount%'Anzahl sichbarer Workstations       
  
 
 
     'Hierarchie-DLL
     'I   : RÅckgabe der ausgewÑhlten FilialNr; -1 bei Abbruch
     'C   : Pfad zum TXT-File mit Hierarchie-Abbild
     'I   : Vorauswahl fÅr FilialNr; Wurzel, wenn Wert nicht ex.
     'C   : Aktion (max. 2 Zeilen); Wordwrap
     'C   : Info (max Zeilen); Wordwrap
     'I   : 0 - Ok-Button, 1 - AuswÑhlen/Abbrechen

     WinDir$ = ""
     a% = CALL ("GetWindowsDirectory",WinDir$,128)
     IF EXISTS (WinDir$ + "\CODieLIB.dll") OR EXISTS (_remotepath$ + "CODieLIB.dll") THEN 
          'REGISTER "hiera.dll","_SelectOffice","IC"
          REGISTER "CODieLIB.dll","_SelectOffice","ICICCI"
     ELSE 
          CALL Fehler("Die Bibliothek 'hiera.dll' konnte nicht geladen werden!","")
     END IF 
           
    'auch untergeordnete BÅros anzeigen?
    GLOBAL ShowOther%
    ShowOther% = - 1

     GLOBAL jaRecField$'das eigene RecStatus-Feld    
     GLOBAL WksStufe%'Hierarchie-Level ermitteln  
     
     'Filial-Hierarchie-Infos einlesen
     CALL ReadHiera()
 

 GLOBAL gMaxLocalCode%'ID-Range-Trennung zwischen Filiale und Zentrale
 gMaxLocalCode% = 2000000
 
 'TState-Konstanten fÅr Abgleich "lokal -> zentral"
 'genutzter Zeichenbereich: "0" ... "9", "A" ... "Z","a" ... "z"..
 '(..entspricht 48 ... 57, 65 ... 90,97 ... 122)
 'Zwischen den ZustÑnden jeweils 8 Zeichen Platz lassen
 GLOBAL glcStart$,glcCenter1$,glcCenter2$,glcSub1$,glcSub2$
 GLOBAL glcSubCenter1$,glcSubCenter2$,glcLocal1$,glcLocal2$
 GLOBAL glcMainToSub1$,glcMainToSub2$,glcMainToSub3$
 glcStart$ = ""
  
 'Vorgang 1.4.1
 'DatenÅbertragung und RÅckschreiben der neuen zentralen ID'S
 glcCenter1$ = "A"
 glcCenter2$ = "B"'lokaler Datensatz wurde in Zentrale kopiert und zentrale ID wurde in die *Send Åbernommen
 
 
 'Vorgang 1.4.1.1
 'öbergabe der Main-ID's an die Sub-Files
 'Schreiben in die TState-Felder der Main-Files
 glcMainToSub1$ = "J"'bei öbergabe traten Fehler auf; öbergabe kann noch (weiter)laufen
 glcMainToSub2$ = "K"'öbergabe lÑuft noch; bisher ohne Fehler
 glcMainToSub3$ = "L"'öbergabe komplett
 
 
 'Vorgang 1.4.2
 'Untergeordnete lokale DatensÑtze wurden in Zentrale kopiert und zentrale ID wurde Åbernommen
 glcSubCenter1$ = "S"
 glcSubCenter2$ = "T"
 
 
 'öbernahme der (neuen) zentralen ID's in die lokalen Dateien
 glcLocal1$ = "b"
 glcLocal2$ = "c"
 
 'Parameter-Konstanten fÅr Funktionsaufrufe
 GLOBAL jaSFile$,jaSCode$,jaSCodeServer$,jaSTState$,jaSRStat$
 GLOBAL jaCFile$,jaCCode$,jaCRStat$
 GLOBAL jaLFile$'hier nur zum Schlie·en der lokalen adressen.sbf  
 GLOBAL jaSSubFile$,jaSMainCode$,jaSMainCode2$,jaSMainCode3$,jaSMainCode4$,jaSSubTState$
 GLOBAL jaSSubRStat$,jaSSubCodeServ$,jaSSubCode$
 GLOBAL jaCSubServWork$,jaCSubCode$,jaCMainCode$,jaCSubFile$,jaCSubRStat$
 GLOBAL jaLSubFile$
 GLOBAL jaLCode$,jaLMainCode$,jaLMainCode2$,jaLMainCode3$,jaLMainCode4$,jaLRStat$
 GLOBAL jaLSubCode$,jaLSubRStat$
 GLOBAL jaFirstSubFile%,jaLastSubFile%'bool
 GLOBAL jaIsMain%'fÅr SendMain() (bzw. SendFile)
 GLOBAL jaDummySub%'  fÅr Files, die zwar zentrale ID's Åber MainToSub() bekommen, 
                   '  aber selbst nicht zur Zentrale abgeglichen werden
 GLOBAL jaSendSucc%'war der gesamte(!) Send-Vorgang erfolgreich?
 GLOBAL jaCTLSucc%'war der CenterToLoad-Vorgang erfolgreich?
 GLOBAL jaLTLSucc%'war der LoadToLocal-Vorgang erfolgreich?

 GLOBAL jaTyp1To1%,jaFilePrefix$,jaFileTyp$,jaFileCode$
 
 'Konstanten fÅr Log-File-Erzeugung
 GLOBAL jaLogFile$
 GLOBAL jaLogRepeat$' Abgleich hat nicht fkt. ==> zurÅcksetzen der TState-Konstante fÅr einen neuen Versuch
 GLOBAL jaLogOk$'
 GLOBAL jaLogError$'irgend etwas ist schief gelaufen
 GLOBAL jaLogNew$'neuer Datensatz wird erstellt
 GLOBAL jaLogCopy$' Datensatz wird Åbernommen
 GLOBAL jaLogPass$'ID in die untergeordneten Send-Files reichen (MainToSub)
 GLOBAL jaLogIter$'nur fÅr Fehler in Ñu·erer verschachtelter while-Schleife
 jaLogRepeat$ = "Repeat"
 jaLogOk$ = "Ok"
 jaLogError$ = "Error"
 jaLogNew$ = "New"
 jaLogCopy$ = "Copy"
 jaLogPass$ = "Pass"
 jaLogIter$ = "Iter"
 GLOBAL jaLoadSubOff%'sollen die Daten der untergeordneten BÅros beim Download Åbernommen werden ?
 GLOBAL jaCenterDirty%'-1 -> LoadToLocal ist spÑtestens mit dem nÑchsten Programmstart nîtig


 Superbase.ErrorTrapLabel = oldErrorLabel$
 END SUB 
  '***********************************************************************************************
 

SUB Abgleich()
 'Datenabgleich
 oldErrorLabel$ = Superbase.ErrorTrapLabel

 IF NOT OPEN ("abgfiles") THEN OPEN FILE SHARE ,1_remotepath$ + "abgfiles;paris"
 IF NOT OPEN ("abgdeps") THEN OPEN FILE SHARE ,1_remotepath$ + "abgdeps;paris"
 
 CALL AbgleichInit()
 jaCenterDirty% = VAL (ReadConfig$("PROVIS","LTL"))
 
 IF GPPCS$ LIKE "TRUE" THEN 
        
    IF Workstation% <> 0 THEN 
        
          IF jaDebug% = - 1 THEN CALL Fehler ("Abgleich-Vorbereitung","")

          'Dialog fÅr Abgleichtyp-Abfrage holen
          AblTyp% = 1'1 -> kein Abgleich, 2 -> nur Send(), 3 -> Send + Load
          jaLoadSubOff% = 0' -1 -> auch Daten untergeordneter BÅros downloaden ?

          CALL AbglDlg(Ant%%,AbglTyp%,jaLoadSubOff%)
          
          IF Ant%% <> 1 THEN 'Dlg mit Cancel beendet ==> Voreinstellung "kein Abgleich"
               AblTyp% = 1'
               jaLoadSubOff% = 0'
          END IF 
          
         
          IF (AbglTyp% = 2) OR (AbglTyp% = 3) THEN 
            
               IF IsSingleUser%() = - 1 THEN 

                    CALL SetDisplay(0)
                    DIM w AS SDIWindow 
                    SET w = Superbase.Windows(1)
                    w.Form.FktL.Caption = "Ableich vorbereiten ..."
   
                    'Abgleich starten
                    ON ERROR GOTO ErrorHandler
                    IF jaDebug% = - 1 THEN CALL Fehler ("Abgleich-Start","")
             
                    CALL CAbgleichLog("sed")
                    CALL Send()
            
                    IF AbglTyp% = 3 THEN 

                         CALL CAbgleichLog("ctl")
                         CALL CenterToLoad()
                        
                         CALL CAbgleichLog("ltl")
                         CALL LoadToLocal()
                    END IF 
               ELSE 
                    CALL Fehler("Es wurde kein Datenabgleich vorgenommen!","")
               END IF 
 
               'Standard-Fenster-Eigenschaften zurÅcksetzen
               CALL SetDisplay( - 1)
          END IF 
             
    END IF 'Worksation% <> 0 
 ELSE 
     'GPPCS$=FALSE
     IF jaCenterDirty% <> 0 THEN 
          'LoadToLocal mu· ausgefÅhrt werden 
          CALL Fehler("Bei der letzten Programm-Sitzung wurden zentralen Daten geÑndert.","Diese énderungen werden nun Åbernommen.")
          IF IsSingleUser%() = - 1 THEN 

               CALL SetDisplay(0)'Abgleich-Formular laden/erzeugen
               CALL CAbgleichLog("ltl")
               CALL LoadToLocal()
               CALL SetDisplay( - 1)'Abgleich-Formular laden/erzeugen
     
               IF jaLTLSucc% = - 1 THEN 
                    CALL WriteConfig("PROVIS","LTL","0")
               ELSE 
                    CALL Fehler("Die öbernahme der Zentralen Daten konnte nicht vollstÑndig vorgenommen werden."," Es wird empfohlen das Programm neu zu starten und den Vorgang zu wiederholen.")
               END IF 
          ELSE 
               CALL Fehler("Die öbernahme der Zentralen Daten konnte nicht vorgenommen werden.","Es wird empfohlen, das Programm neu zu starten und den Vorgang zu wiederholen.")
          END IF 

     END IF 
 END IF 
 Superbase.ErrorTrapLabel = oldErrorLabel$
 END SUB 
 '***********************************************************************************************
 
 
FUNCTION IsSingleUser%()
 'prÅft, ob der aktuelle der einzige User ist
 '-1 wenn ja
 '0 wenn nein
 '
 'erzeugt Schleife, in der der User Gelegenheit bekommt, andere User aus dem Programm zu schmei·en

 oldErrorLabel$ = Superbase.ErrorTrapLabel
 IsSingleUser% = 0
 DIRECTORY _remotepath$

SingleUserStart:   
            
            ON ERROR GOTO SingleUserError
            IF OPEN ("supervis") THEN CLOSE FILE "supervis"
            OPEN FILE SHARE ,8"supervis;paris"
            CLOSE FILE "supervis"
            'bisher alles io
            GOTO SingleUserContin
 
SingleUserError: 
            a$ = "öberprÅfen Sie, ob Sie der einzige Nutzer des Programmes sind."
            REQUEST "Der ausschliesslicher Zugriff konnte nicht erfolgen.",a$,113
            REQUEST "WÑhlen Sie 'Ja', wenn Sie den Vorgang jetzt fortsetzen mîchten.","WÑhlen Sie 'Nein', wenn Sie den Datenabgleich Åberspringen wollen.",130,Ant%%
            IF Ant%% = 0 THEN 
                RESUME SingleUserEnd
            ELSE 
                RESUME SingleUserStart 
            END IF 
 
SingleUserContin:                         
            IsSingleUser% = - 1

SingleUserEnd: 
          CALL DFile(2,"supervis;paris")'wieder îffnen 

 Superbase.ErrorTrapLabel = oldErrorLabel$
 END FUNCTION 

 '*********************************************************************************************** 

SUB ActivateHiera()
     Superbase.Dialogs.ABGL.HieraCB.Enabled = - 1
 END SUB 
 '***********************************************************************************************
  

SUB DeactivateHiera()
     Superbase.Dialogs.ABGL.HieraCB.Enabled = 0
 END SUB 
 '*********************************************************************************************** 

 
SUB ActivateABGL()
     'REQUEST "Activate"
     Superbase.Dialogs.ABGL.UDNoneOB.Value = - 1
     Superbase.Dialogs.ABGL.HieraCB.Enabled = 0
 END SUB 
 '*********************************************************************************************** 


SUB AbglDlg(Ant%,AbglTyp%,HieraTyp%)
 
    DIM dlg AS Dialog
    DIM control AS DialogControl
 
    Superbase.Dialogs.Add("ABGL")
    SET dlg = Superbase.Dialogs.ABGL
    dlg.Move(76,34,204,160)
    dlg.Caption = "Daten-Abgleich"
    dlg.FontName = "MS Sans Serif"
    dlg.FontSize = 10
    dlg.OnActivate = "ActivateABGL"
 
    SET control = dlg.Add("DialogLabel1","DialogLabel")
    control.Move(20,12,132,12)
    control.Caption = "Bitte wÑhlen Sie die Art des Abgleiches."
 
    SET control = dlg.Add("DialogIcon1","DialogIcon")
    control.Move(2,10,16,18)
    control.Icon = 2
 
    SET control = dlg.Add("DialogLabel2","DialogLabel")
    control.Move(20,33,172,31)
    control.Caption = "Hinweis: Wenn Sie einen Daten-Abgleich vornehmen wollen, mÅssen alle anderen Nutzer die Arbeit mit dem Programm einstellen."
 
    SET control = dlg.Add("UDNoneOB","DialogOptionButton")
    control.Move(20,68,130,15)
    control.Caption = "Kein Abgleich"
    control.Bind("AbglTyp%")
    control.ValueOn = 1
    control.OnClick = "DeactivateHiera"
 
    SET control = dlg.Add("DialogOptionButton2","DialogOptionButton")
    control.Move(20,81,130,15)
    control.Caption = "Lokale Daten senden"
    control.Bind("AbglTyp%")
    control.ValueOn = 2
    control.OnClick = "DeactivateHiera"
 
    SET control = dlg.Add("DUOption","DialogOptionButton")
    control.Move(20,95,171,15)
    control.Caption = "Lokale Daten senden und zentrale Daten empfangen"
    control.Bind("AbglTyp%")
    control.ValueOn = 3
    control.OnClick = "ActivateHiera"
 
    SET control = dlg.Add("HieraCB","DialogCheckBox")
    control.Move(34,109,150,14)
    control.Bind("HieraTyp%")
    control.ValueOn = - 1
    control.Caption = "Daten untergeordneter BÅros einschlie·en"
    control.OnClick = "ActivateHiera"
 
    SET control = dlg.Add("DialogCommandButton1","DialogCommandButton")
    control.Move(71,135,52,12)
    control.Default = 1
    control.Caption = "Ok"
    control.ReturnValue = 1

     DIALOG "ABGL",Ant%
     REMOVE DIALOG "ABGL"
 
 END SUB 
 '*********************************************************************************************** 


SUB ReadHiera()
     oldErrorLabel$ = Superbase.ErrorTrapLabel

    'die Daten der LFILIALE kopieren
    ON ERROR GOTO ReadHieraErr
    CALL DFile(2,"LFILIALE;paris")
    OffCount% = 0
    VisCount% = 0
    REM CALL Fehler("ReadHiera","")
    IF GPPCS$ LIKE "TRUE" OR Workstation% = 0 THEN 
       
        CALL ReadHArray("filiale",OffCount%)
        'sichtbare Workstations aus VorgÑnger%, Nachfolger%, OffCount% holen
        CALL GetVisOff(Workstation%)
        'sich selbst noch zu den sichbaren BÅros hinzufÅgen
        VisCount% = VisCount% + 1
        REDIM VisOff%(VisCount% - 1)
        REDIM VisNames$(VisCount% - 1)
        VisOff%(VisCount% - 1) = Workstation%
        REM CALL Fehler("VisNames$","")
        VisNames$(VisCount% - 1) = GetWksName$(Workstation%)
        
        'die lokale lfiliale aus den sichtbaren BÅros neu aufbauen
        '(fÅr den nÑchsten Offline-Start)
        REM REMOVE FROM FILE "lfiliale"
 
        'das hîchste BÅro immer per Def. eintragen (Zentrale)
        SELECT FIRST FILE "filiale" INDEX filialnr.filiale
        SELECT KEY 0 FILE "filiale" INDEX filialnr.filiale
        REM CALL Fehler(Name.filiale,"")
        IF EXISTS (filialnr.filiale,filialnr.lfiliale) THEN 
          SELECT KEY filialnr.filiale LOCK FILE "lfiliale" INDEX filialnr.lfiliale
            Name.lfiliale = Name.filiale
            Stufe.lfiliale = Stufe.filiale
            VorgÑnger.lfiliale = VorgÑnger.filiale
            STORE FILE "lfiliale"
        ELSE 
            BLANK FILE "lfiliale"
            filialnr.lfiliale = filialnr.filiale
            Name.lfiliale = Name.filiale
            Stufe.lfiliale = Stufe.filiale
            VorgÑnger.lfiliale = VorgÑnger.filiale
            STORE FILE "lfiliale"
        END IF 
        'den Pfad vom aktuellen BÅro bis zur Zenrale: 
        'suche solange den VorgÑnger, bis die 0 erreicht wird
        ON ERROR GOTO ErrorHandler
        wks% = GetWksVorg%(Workstation%)
        
        WHILE wks% > 0
            SELECT FIRST FILE "filiale" INDEX filialnr.filiale
            SELECT KEY wks% FILE "filiale" INDEX filialnr.filiale
            IF FOUND ("filiale") THEN 
              IF EXISTS (filialnr.filiale,filialnr.lfiliale) THEN 
                SELECT KEY filialnr.filiale LOCK FILE "lfiliale" INDEX filialnr.lfiliale
                Name.lfiliale = Name.filiale
                Stufe.lfiliale = Stufe.filiale
                VorgÑnger.lfiliale = VorgÑnger.filiale
                STORE FILE "lfiliale"
              ELSE 
                BLANK FILE "lfiliale"
                filialnr.lfiliale = filialnr.filiale
                Name.lfiliale = Name.filiale
                Stufe.lfiliale = Stufe.filiale
                VorgÑnger.lfiliale = VorgÑnger.filiale
                STORE FILE "lfiliale"
              END IF 
            END IF 
            wks% = GetWksVorg%(wks%)
        WEND 
 
        'die restlichen sichtbaren BÅros, einschl. sich selbst (untergeordnete BÅros)
        FOR i%% = 0 TO VisCount% - 1
            SELECT KEY VisOff%(i%%) FILE "filiale" INDEX filialnr.filiale
            IF FOUND ("filiale") THEN 
              IF EXISTS (filialnr.filiale,filialnr.lfiliale) THEN 
                SELECT KEY filialnr.filiale LOCK FILE "lfiliale" INDEX filialnr.lfiliale
                Name.lfiliale = Name.filiale
                Stufe.lfiliale = Stufe.filiale
                VorgÑnger.lfiliale = VorgÑnger.filiale
                STORE FILE "lfiliale"
              ELSE 
                BLANK FILE "lfiliale"
                filialnr.lfiliale = filialnr.filiale
                Name.lfiliale = Name.filiale
                Stufe.lfiliale = Stufe.filiale
                VorgÑnger.lfiliale = VorgÑnger.filiale
                STORE FILE "lfiliale"
              END IF 
            END IF 
            ON ERROR GOTO ErrorHandler
            SELECT NEXT FILE "filiale" INDEX filialnr.filiale
        NEXT i%%
    ELSE 
    'wenn nicht online ==> lfiliale nutzen, um BÅro-Hierarchie einzulesen
        SELECT FIRST FILE "filiale" INDEX filialnr.filiale
        SELECT KEY 0 FILE "filiale" INDEX filialnr.filiale
        REM CALL Fehler(Name.filiale,"")
        WHILE NOT EOF ("filiale")
          IF EXISTS (filialnr.filiale,filialnr.lfiliale) THEN 
            SELECT KEY filialnr.filiale LOCK FILE "lfiliale" INDEX filialnr.lfiliale
            Name.lfiliale = Name.filiale
            Stufe.lfiliale = Stufe.filiale
            VorgÑnger.lfiliale = VorgÑnger.filiale
            STORE FILE "lfiliale"
          ELSE 
            BLANK FILE "lfiliale"
            filialnr.lfiliale = filialnr.filiale
            Name.lfiliale = Name.filiale
            Stufe.lfiliale = Stufe.filiale
            VorgÑnger.lfiliale = VorgÑnger.filiale
            STORE FILE "lfiliale"
          END IF 
          SELECT NEXT FILE "filiale" INDEX filialnr.filiale
        WEND 
        REM CALL Fehler("ReadHiera-Stufe1","")
        CALL ReadHArray("lfiliale",OffCount%)
        VisCount% = 0
        CALL GetVisOff(Workstation%)'sichtbare Workstations aus zentraler filiale.sbf holen   
        'sich selbst noch zu den sichbaren BÅros hinzufÅgen
        VisCount% = VisCount% + 1
        REDIM VisOff%(VisCount% - 1)
        REDIM VisNames$(VisCount% - 1)
        VisOff%(VisCount% - 1) = Workstation%
        REM CALL Fehler("VisNames$","")
        VisNames$(VisCount% - 1) = GetWksName$(Workstation%)
 
    END IF 

    'Hierarchie-Level ermitteln 
     SELECT FIRST FILE "lfiliale" INDEX FilialNr.lFiliale
     SELECT KEY Workstation% FILE "lfiliale" INDEX FilialNr.lFiliale
          IF FOUND ("lfiliale") THEN 
               WksStufe% = Stufe.lFiliale
          ELSE 
               CALL Fehler("UngÅltige Filial-Nummer: " + STR$ (Workstation%,"z"),"")
          END IF 
     END IF 
 
     'das eigene RecStatus-Feld und den Dirty-Wert errechnen
     IF WksStufe% = 0 THEN 
          jaRecField$ = "rec0"'Sonder-Behandlung fÅr die Null
     ELSE 
          jaRecField$ = "rec" + STR$ (WksStufe%,"z")
     END IF 

     'alles io
     GOTO ReadHieraEnde
 
ReadHieraErr: 
     CALL Fehler("Fehler bei öbertragung der Filial-Hierarchie:","Fehler " + STR$ ( ERRNO ,"z") + ": " + ERR$ ( ERRNO ))

ReadHieraEnde:  
     Superbase.ErrorTrapLabel = oldErrorLabel$
 END SUB 
 '*********************************************************************************************** 


SUB SimpleConnect(datei$)
    'CALL Fehler("SimpleConnect: " + datei$,"")
    ON ERROR GOTO ConnectError
    IF OPEN (datei$) THEN CLOSE FILE datei$
    DIM sbfile$,ip$,port$,updserver$
    sbfile$ = datei$ + ";paris"
    
    ip$ = "130.50.0.254"
    port$ = "1280"
    udpserver$ = ip$ + ":" + port$
    Connections.Clear()
    IF NOT Connections.Exists("CODIE") = - 1 THEN 
        Connections.Add("CODIE","ConnectionUDPClient").ServerName = udpserver$
        Superbase.Connections.CODIE.Timeout = 8000
    END IF 
    
    OPEN FILE SHARE ,1"CODIE:" + sbfile$
 
    GOTO ConnectEnde
 
ConnectError: 
    REQUEST "Fehler " + STR$ ( ERRNO ,"z") + ": " + ERR$ (Superbase.LastError)
 
ConnectEnde: 
 
 END SUB 
 '***********************************************************************************************  
 
 
 
 
FUNCTION IsOnline%(datei$)
 'Online-Test fÅr Dateien  
 ' PrÅft, ob Datei Åber PPCS geîffnet wurde (RÅckgabe -1) oder nicht (RÅckgabe 0)
    oldErrorLabel$ = Superbase.ErrorTrapLabel
    ON ERROR GOTO IsOnlineError
    
    OPEN "status.txt" FOR OUTPUT 
    ? STATUS FILE datei$
    CLOSE OUTPUT 
 
    OPEN "status.txt" FOR INPUT 
    INPUT LINE a$
    CLOSE INPUT 
    
    x$ = "CODIE:"
    pos% = INSTR (a$,x$)
    IF (pos% <> 0) THEN 
        IsOnline% = - 1
    ELSE 
        IsOnline% = 0
    END IF 
 
    'alles io
    GOTO IsOnlineEnde
 
IsOnlineError: 
    IsOnline% = 0
    GOTO IsOnlineEnde
 
IsOnlineEnde: 
    Superbase.ErrorTrapLabel = oldErrorLabel$
 
 END FUNCTION 
 '***********************************************************************************************  


FUNCTION GetFileCode$(datei$)
 'liefert den Namen des Code-Feldes zurÅck
    SELECT FIRST FILE "AbgFiles" INDEX FileName.AbgFiles
    SELECT KEY datei$ FILE "AbgFiles" INDEX FileName.AbgFiles
    GetFileCode$ = CodeField.AbgFiles
 
 END FUNCTION 
 '***********************************************************************************************

 
FUNCTION GetFileTyp$(datei$)
 'liefert den Abgleich-Typ der Datei zurÅck (I, "", C, Z, A, Y)
    SELECT FIRST FILE "AbgFiles" INDEX FileName.AbgFiles
    SELECT KEY datei$ FILE "AbgFiles" INDEX FileName.AbgFiles
    GetFileTyp$ = Typ.AbgFiles
 END FUNCTION 
 '***********************************************************************************************  


FUNCTION GetFilePrefix$(datei$)
 'liefert den Namen des Prefix' fÅr die Send/Load-Dateien zurÅck
    SELECT FIRST FILE "AbgFiles" INDEX FileName.AbgFiles
    SELECT KEY datei$ FILE "AbgFiles" INDEX FileName.AbgFiles
    GetFilePrefix$ = Prefix.AbgFiles
 END FUNCTION 
 '*********************************************************************************************** 

SUB GetFileInfo(datei$)
 'setzt globale Variablen, auf die File-Infos
 'wenn keine Infos verfÅgbar (datei$ nicht in AbgFiles) ==> jaFileTyp$ = ""
     datei$ = UCASE$ (datei$)
     jaFilePrefix$ = ""
     jaFileTyp$ = ""
     jaFileCode$ = ""
     jaTyp1To1% = 0
     IF NOT EXISTS (datei$,FileName.AbgFiles) THEN 
          END SUB 
     END IF 
     SELECT FIRST FILE "AbgFiles" INDEX FileName.AbgFiles
     SELECT KEY datei$ FILE "AbgFiles" INDEX FileName.AbgFiles
     jaFilePrefix$ = Prefix.AbgFiles
     jaFileTyp$ = Typ.AbgFiles
     jaFileCode$ = CodeField.AbgFiles
     jaTyp1To1% = (Typ1To1.AbgFiles = "J")
 END SUB 
 '***********************************************************************************************  

 '--------------------------------------------------------------------
 '-------- Hierarchie - Routinen -------------------------------------
 '-------------------------------------------------------------------- 
 
FUNCTION AddOffice%(nameneu$)
    datei$ = "FILIALE"
    'neues BÅro unterhalb eines wÑhlbaren BÅros erzeugen
    'liefert die neue BÅro-Nummer zurÅck bzw. -1, wenn Fehler oder Abbruch
    'und positioniert "filiale" auf den neuen Datensatz
    'geht davon aus, da· Datei "Filiale" geîffnet ist
    'Aufruf nur von Zentrale (Workstation% = 0)
    'nimmt kein STORE vor
 
     'mainwks% vom User erfragen
     AddOffice% = - 1
     mainwks% = SelectOffice%("Neue Filiale erstellen","WÑhlen Sie einen VorgÑnger fÅr die neue Filiale.",1, - 1)
     IF mainwks% = - 1 THEN END FUNCTION 'Cancel-Fall
     SELECT FIRST FILE "filiale" INDEX Filialnr.Filiale
     SELECT KEY mainwks% FILE "filiale" INDEX Filialnr.Filiale
     IF NOT FOUND ("filiale") THEN 
          CALL Fehler("Fehler: öbergeordnete Filiale nicht gefunden:",GetWksName$(mainwks%))
          END FUNCTION 
     END IF 
     
     wks$ = "Filialnr.filiale"
     vorg$ = "vorgÑnger.filiale"
     level$ = "Stufe.filiale"
     name$ = "Name.filiale"
     name2$ = "Nachname.filiale"
     datei$ = "filiale"
     
     wksneu% = SER (datei$,1)
     levelneu% = level$$ + 1
 
     'Filiale-Datensatz erzeugen
     BLANK FILE datei$
     wks$$ = wksneu%
     vorg$$ = mainwks%
     level$$ = levelneu%
     name$$ = nameneu$
     name2$$ = nameneu$
     STORE FILE datei$

     AddOffice% = wksneu%'RÅckgabe-Wert

 END FUNCTION 
 '***********************************************************************************************
 
 
SUB ReadHArray(datei$,z%)
 'liest das gesamte(!) Hierarchie-Array fÅr eine bestimmte _datei$ ein
 'z% gibt als call by reference die Anzahl zurÅck
 
     datei$ = UCASE$ (datei$)
     SELECT CASE datei$
          CASE "FILIALE","LFILIALE"
               vorgaenger$ = "VorgÑnger"
               nachfolger$ = "FilialNr"
               name$ = "Name"
     END CASE 
     codefield$ = nachfolger$ + "." + datei$
     vorgfield$ = vorgaenger$ + "." + datei$
     namefield$ = name$ + "." + datei$
            
     z% = 0
     SELECT FIRST FILE datei$ INDEX codefield$$
     WHILE NOT EOF (datei$)
     
          IF (vorgfield$$ >= 0) AND (codefield$$ >= 0) THEN 
               REDIM Nachfolger%(z%)
               REDIM VorgÑnger%(z%)
               REDIM OffNames$(z%)
               IF codefield$$ < 1 THEN 
                   Nachfolger%(z%) = 0
               ELSE 
                   Nachfolger%(z%) = codefield$$
               END IF 
               IF vorgfield$$ < 1 THEN 
                   VorgÑnger%(z%) = 0
               ELSE 
                   VorgÑnger%(z%) = vorgfield$$
               END IF 
 
               OffNames$(z%) = namefield$$
               z% = z% + 1
          END IF 

          SELECT NEXT FILE datei$ INDEX codefield$$
     WEND 
     REM CALL Fehler("ReadHiera 3","")
     '? STR$ (z%) + " EintrÑge insgesamt"

 END SUB 
 '***********************************************************************************************
 
 
SUB GetVisOff(startcode%)
 'Sichbare BÅros ermitteln: fÅllt VisOff% und setzt VisCount%
 'VisCount% mu· vorher auf 0 gesetzt werden  
 'nutzt golbale Variablen VorgÑnger%, Nachfolger%, OffCount%
 'Workstation% wird als startcode% Åbergeben
 'fÅgt das aktuelle BÅro nicht mit ein !!!
        
    pos% = 0
    vorg% = startcode%
    x% = 0
    z% = 0
    zaehl% = 0
    REM IF workstation% = 0 THEN VisCount% = 0
    REM IF workstation% <> 0 THEN VisCount% = 0
    REM CALL Fehler("VisNames$","")
    WHILE pos% < OffCount%
        'den nÑchsten Nachfolger von startcode% (also vorg%) bestimmen
        IF workstation% = 0 THEN 
          REM IF (VorgÑnger%(pos%) = vorg%) AND (Nachfolger%(pos%) <> VorgÑnger%(pos%)) THEN 
            'also ein direkter/indirekter Nachfolger gefunden
            VisCount% = VisCount% + 1
            REDIM VisOff%(VisCount% - 1)
            REDIM VisNames$(VisCount% - 1)
            x% = Nachfolger%(pos%)
            REM 25102002 VisOff%(VisCount% - 1) = x%
            VisOff%(VisCount% - 1) = x%
            REM CALL Fehler("VisNames$","")
            VisNames$(VisCount% - 1) = OffNames$(pos%)
            REM z% = x%
            REM VisCount% = VisCount% + 1
            REM CALL GetVisOff(Nachfolger%(pos%))'Rekursion
          REM END IF 
        ELSE 
          IF (VorgÑnger%(pos%) = vorg%) AND (Nachfolger%(pos%) <> VorgÑnger%(pos%)) THEN 
            'also ein direkter/indirekter Nachfolger gefunden
            REM VisCount% = VisCount% + 1
            REDIM VisOff%(VisCount%)
            REDIM VisNames$(VisCount%)
            x% = Nachfolger%(pos%)
            IF z% <> x% THEN 
              REM 25102002 VisOff%(VisCount% - 1) = x%
              REM 14052003 VisOff%(VisCount% - 1) = x%
              REM CALL Fehler("VisNames$","")
              REM CALL Fehler(OffNames$(pos%),"")
 
              VisNames$(VisCount%) = OffNames$(pos%)
              VisOff%(VisCount%) = x%
              z% = x%
              VisCount% = VisCount% + 1
            END IF 
            CALL GetVisOff(Nachfolger%(pos%))'Rekursion
          END IF 
        END IF 
        pos% = pos% + 1
    WEND 
 
 
 END SUB 
 '***********************************************************************************************
 

SUB PrintHierarchy(datei$,startcode%,lines$)
 'gibt die Hierarchie von _datei$ als Text-Report aus 
 
    datei$ = UCASE$ (datei$)
    SELECT CASE datei$
        CASE "OFFICE"
            vorgaenger$ = "VorgÑnger"
            nachfolger$ = "Workstation"
            info$ = "Name"
            stufe$ = "Level"
        CASE "FILIALE"
            vorgaenger$ = "VorgÑnger"
            nachfolger$ = "FilialNr"
            info$ = "Name"
            stufe$ = "Stufe"
 
    END CASE 
    codefield$ = nachfolger$ + "." + datei$
    vorgfield$ = vorgaenger$ + "." + datei$
    infofield$ = info$ + "." + datei$
    levelfield$ = stufe$ + "." + datei$
 
    horz$ = "-"
    vert$ = "|"
    einstieg$ = vert$ + horz$
    code2% = startcode%
 
 
    'fÅrs Baum-Zeichnen: die Anzahl der direkten Nachfolger bestimmen
    pos% = 0
    FOR pos% = 0 TO OffCount% - 1
        'den nÑchsten Nachfolger von codema2% bestimmen
        IF (VorgÑnger%(pos%) = code2%) THEN 
            maxNachfolger% = Nachfolger%(pos%)
        END IF 
    NEXT pos%
    
    'Ausgabe des (aktuellen) VorgÑngers
    SELECT FIRST FILE datei$ INDEX codefield$$
    SELECT KEY code2% FILE datei$ INDEX codefield$$
     
    ? infofield$$ + " (" + STR$ (levelfield$$,"000.") + ")"
    tempstufe% = levelfield$$
 
    pos% = 0
    WHILE pos% < OffCount%
        'den nÑchsten Nachfolger von codema2% bestimmen
        IF (VorgÑnger%(pos%) = code2%) THEN 
            IF (Nachfolger%(pos%) = maxNachfolger%) THEN 
                sublines$ = lines$ + "  "
            ELSE 
                sublines$ = lines$ + vert$ + " "
            END IF 
            ? lines$ + einstieg$;'die Einstiegs-Linie fÅr den Nachfolger   
            CALL PrintHierarchy(datei$,Nachfolger%(pos%),sublines$)'Rekursion
        END IF 
 
        pos% = pos% + 1
    WEND 
        
    IF tempstufe% = 2 THEN ? lines$'sieht besser aus
 
 END SUB 
 '***********************************************************************************************
 
 
FUNCTION IsWksVisible%(wks%)
 'prÅft, ob die Åbergebene Workstation im Array der sichbaren Workstations enthalten ist    
    'CALL Fehler( STR$ (wks%,"z"),"")
 
    'CALL Fehler("","")
    IF ShowOther% <> - 1 THEN 
        'nur ein bestimmtes BÅro?
        IsWksVisible% = (wks% = ShowOther%)
    ELSE IsWksVisible% = 0
    
        IF Workstation% = 0 THEN 'Fall Zentrale
            IsWksVisible% = - 1
            END FUNCTION 
        END IF 
 
        FOR i% = 0 TO VisCount% - 1' Fall externes BÅro
            IF VisOff%(i%) = wks% THEN 
                'CALL Fehler( STR$ (wks%,"z"),"")
                IsWksVisible% = - 1
                i% = VisCount%
            END IF 
        NEXT i%
    END IF 
 
 END FUNCTION 
 '***********************************************************************************************
 

FUNCTION GetWksName$(wks%)
 'liefert den BÅro-Namen anhand der BÅronummer
 GetWksName$ = "unbekannt"
        
        FOR i% = 0 TO OffCount% - 1
 
            IF Nachfolger%(i%) = wks% THEN 
 
                GetWksName$ = OffNames$(i%)
                i% = OffCount%
 
            END IF 
 
        NEXT i%
 
 END FUNCTION 
  '***********************************************************************************************
 
FUNCTION GetWksVorg%(wks%)
 'liefert den VorgÑnger fÅr eine BÅronummer
 GetWksVorg% = - 1
        
        FOR i% = 0 TO OffCount% - 1
 
            IF Nachfolger%(i%) = wks% THEN 
 
                GetWksVorg% = VorgÑnger%(i%)
                i% = OffCount%
 
            END IF 
 
        NEXT i%
 
 END FUNCTION 
 '***********************************************************************************************
 
FUNCTION GetWksIndex%(wks%)
 'liefert den Index der Workstation aus dem Wks-Array (also aus Nachfolger%)
 GetWksIndex% = - 1
        
        FOR i% = 0 TO OffCount% - 1
 
            IF Nachfolger%(i%) = wks% THEN 
 
                GetWksIndex% = i%
                i% = OffCount%
 
            END IF 
 
        NEXT i%
 END FUNCTION 
 '***********************************************************************************************


FUNCTION GetVisWksIndex%(wks%)
 'liefert den Index der Workstation aus dem "sichtbar"-Array der (also aus VisOff%)
 GetWksIndex% = - 1
        
        FOR i% = 0 TO VisCount% - 1
 
            IF VisOff%(i%) = wks% THEN 
 
                GetWksIndex% = i%
                i% = OffCount%
 
            END IF 
 
        NEXT i%
 END FUNCTION 
 '*********************************************************************************************** 

FUNCTION SelectOffice%(action$,info$,buttons%,aktwks%)
 REM CALL Fehler("SelectOffice%","")
 'Tree-Auswahl eines BÅros mit Hilfe von hiera.dll
 'txt-file mit Struktur der sichtbaren BÅros erzeugen und 
 'hiera.dll::_SelectOffice aufrufen
 'txt-File: Zentrale ... Pfad zum aktuellen BÅro ... untergeodnete BÅros
 
 info$ = FN ANSI(info$)
 action$ = FN ansi(action$)

 IF EXISTS (_localpath$ + "hiera.txt") THEN 
    DELETE (_localpath$ + "hiera.txt")
 END IF 
 
 OPEN _localpath$ + "hiera.txt" FOR OUTPUT 
 'das hîchste BÅro immer zuerst
    ? GetWksName$(0)
    ? "0"
    ? "0"
 
 'den Pfad vom aktuellen BÅro bis zur Zenrale: 
 'suche solange den VorgÑnger, bis die 0 erreicht wird
 wks% = GetWksVorg%(Workstation%)
 WHILE wks% > 0
    ? GetWksName$(wks%)
    ? STR$ (wks%,"z")
    wks% = GetWksVorg%(wks%)
    IF wks% = 0 THEN 
        ? "0"
    ELSE 
        ? STR$ (wks%,"z")
    END IF 
 WEND 
 
 'die restlichen Nachfolger (sichtbare BÅros) einschl. sich selbst
 FOR i% = 0 TO VisCount% - 1
     IF VisOff%(i%) <> 0 THEN 'Zentrale schon ausgegeben 
          ? FN ansi(VisNames$(i%))
          ? STR$ (VisOff%(i%),"z")
          wks% = GetWksVorg%(VisOff%(i%))
          IF wks% = 0 THEN 
               ? "0"
          ELSE 
               ? STR$ (wks%,"z")
          END IF 
     END IF 
 NEXT i%
 CLOSE OUTPUT 
 
 SelectOffice% = CALL ("_SelectOffice",_localpath$ + "hiera.txt",aktwks%,action$,info$,buttons%)
 
 DELETE _localpath$ + "hiera.txt"
 
 END FUNCTION 
 '***********************************************************************************************


SUB PrintAbgFiles(txtfile$)
 'Ausgabe der Daten der Datei AbgFiles in eine Text-Datei
 
 OPEN txtfile$ FOR OUTPUT 
    
    ? &10"FileName";
    ? &10"CodeFile";
    ? &8"Prefix";
    ? &5"Typ";
    ? &8"Dir";
    ? &8"Level";
    ? &12"CodeField";
    ? &5"1To1"
    ? "-----------------------------------------------------------------------"
 
 FILE "AbgFiles"
 INDEX FileName
 SELECT FIRST 
 WHILE NOT EOF ("AbgFiles")
    IF Typ <> "I" THEN 
 
    ? &10FileName;
    ? &10 STR$ (CodeFile,"z");
    ? &8Prefix;
    ? &5Typ;
    ? &8Dir;
    ? &8 STR$ (Level,"z");
    ? &12CodeField;
    ? &5Typ1To1
    
    END IF 
    SELECT NEXT 
 
 WEND 
 CLOSE OUTPUT 
 
 
 END SUB 
 '***********************************************************************************************
  
 
SUB AbgPlausi(txtfile$)
 'PlausibilitÑts-PrÅfung fÅr AbgFiles und AbgDeps
 
 IF txtfile$ <> "" THEN 
    OPEN txtfile$ FOR OUTPUT 
 END IF 
 
 path$ = "d:\dkm\muster\"
 
 '1. MainField.AbgDeps mu· in entsprechendem MainFile.AbgFiles existieren
 'Vorgang: Åber alle CodeFile's: FeldInfos holen und prÅfen, ob MainField enthalten ist 
 
 ? "Phase 1 ----------------------"
 
 DIM FieldNames$(1000)
  
 SELECT FIRST FILE "abgDeps" INDEX CodeFile.AbgDeps
 filecode% = CodeFile.AbgDeps
 filename$ = FileName.AbgDeps
 newfile% = - 1
 fieldno% = 0
 WHILE NOT EOF ("AbgDeps")
    IF newfile% = - 1 THEN 
        'Feld-Infos holen            
        SELECT FIRST FILE "AbgFiles" INDEX CodeFile.AbgFiles
        SELECT KEY CodeFile.AbgDeps FILE "AbgFiles" INDEX CodeFile.AbgFiles
        IF FOUND ("AbgFiles") THEN 
            
 
            'REQUEST FileName.AbgDeps
            IF NOT OPEN (FileName.AbgDeps) THEN 
                OPEN FILE SHARE ,1path$ + Dir.AbgFiles + "\" + FileName.AbgDeps + ";paris"
            END IF 

            'Feld-Infos holen
            fieldno% = FILEINFO (FileName.AbgDeps,1)
            REDIM FieldNames$(fieldno%)
            FILLARRAY FieldNames$,1

        ELSE 
            REQUEST "Fehler in Planquadrat 42"
        END IF 
    END IF 
 
 
    'existiert der FeldName?
    fieldFound% = 0
    FOR i% = 0 TO fieldno% - 1
        IF UCASE$ (FieldNames$(i%)) = UCASE$ (MainField.AbgDeps) THEN 
            fieldFound% = - 1
            i% = fieldno%
        END IF 
    NEXT i%
    IF fieldFound% = 0 THEN 
        'nicht plausi. !!!
        ? "AbgDeps: Feld " + MainField.AbgDeps + " ex. nicht in Datei " + FileName.AbgDeps
    END IF 
 
 
    'ist das angegenene MainField tatsÑchlich das Code-Feld des MainFiles?
    '... lÑ·t sich nicht (eindeutig) testen
    '... hîchstens indirekt, z.B. Åber Feld-Format  
 
 
    'Sprung auf nÑchstes File ?
    SELECT NEXT FILE "AbgDeps" INDEX CodeFile.AbgDeps
    IF filecode% <> CodeFile.AbgDeps THEN 
        filecode% = CodeFile.AbgDeps
        filename$ = FileName.AbgDeps
        newfile% = - 1
    ELSE 
        'wenn immernoch die selbe CodeFile ==> auch der Dateinamen darf sich nich Ñndern
        'also PrÅfung, ob Zuordnung zwischen CodeFile.AbgDeps und FileName.AbgDeps 
        'innerhalb der CodeDeps konstant ist - wird aber eigentlich in 2. erledigt
 
        IF filename$ <> FileName.AbgDeps THEN 
            'nicht plausi. !!!
            REQUEST "gaga"
        END IF 
  
    END IF 
 WEND 
 CALL Fehler("","")
 
 '2.PrÅfen,ob Zuordnung zwischen CodeFile.AbgFiles und FileName.AbgFiles Åbereinstimmt 
 ' mit a) Zuordnung zwischen CodeFile.AbgDeps und FileName.AbgDeps 
 ' bzw. b) MainCodeFile.AbgDeps und MainFile.AbgDeps 
 ' bei b) wird zusÑtzlich geprÅft
 
 ? " "
 ? "Phase 2 ----------------------"
 
 UPDATE test.AbgDeps = 0
 WHERE 
 END UPDATE 
 
 z% = 0'Anzahl korrekter Zuordnungen ... mu· am Ende = Reccount("AbgDeps") sein
 SELECT FIRST FILE "AbgFiles" INDEX CodeFile.AbgFiles
 WHILE NOT EOF ("AbgFiles")
            
    a$ = "CodeFile = " + STR$ (CodeFile.AbgFiles,"z") + ": "
 
    ' a)
    SELECT FIRST FILE "AbgDeps" INDEX CodeFile.AbgDeps
    SELECT KEY CodeFile.AbgFiles FILE "AbgDeps" INDEX CodeFile.AbgDeps
    WHILE NOT EOF ("AbgDeps") AND CodeFile.AbgDeps = CodeFile.AbgFiles
        IF UCASE$ (FileName.AbgFiles) <> UCASE$ (FileName.AbgDeps) THEN 
            'nicht plausi. !!            
            ? a$ + "FileName.AbgFiles = " + FileName.AbgFiles + ", FileName.AbgDeps = " + FileName.AbgDeps
        END IF 
        SELECT CURRENT LOCK FILE "AbgDeps" INDEX CodeFile.AbgDeps
        test.AbgDeps = test.AbgDeps + 1
        STORE FILE "AbgDeps"
        UNLOCK CURRENT FILE "AbgDeps"
 
        SELECT NEXT FILE "AbgDeps" INDEX CodeFile.AbgDeps
    WEND 
 
    ' b)
    SELECT FIRST FILE "AbgDeps" INDEX MainCodeFile.AbgDeps
    SELECT KEY CodeFile.AbgFiles FILE "AbgDeps" INDEX MainCodeFile.AbgDeps
    WHILE NOT EOF ("AbgDeps") AND MainCodeFile.AbgDeps = CodeFile.AbgFiles
        IF UCASE$ (FileName.AbgFiles) <> UCASE$ (MainFile.AbgDeps) THEN 
            'nicht plausi. !! 
            ? a$ + "FileName.AbgFiles = " + FileName.AbgFiles + ", FileName.AbgDeps = " + FileName.AbgDeps
        END IF 
        SELECT CURRENT LOCK FILE "AbgDeps" INDEX MainCodeFile.AbgDeps
        test.AbgDeps = test.AbgDeps + 1
        STORE FILE "AbgDeps"
        UNLOCK CURRENT FILE "AbgDeps"
 
        SELECT NEXT FILE "AbgDeps" INDEX MainCodeFile.AbgDeps
    WEND 


            'Feld-Infos fÅr Zeit-Statistik-Felder holen            
            'ON ERROR GOTO IgnoreFile
            'IF NOT OPEN (FileName.AbgFiles) THEN 
            '    OPEN FILE SHARE ,1path$ + Dir.AbgFiles + "\" + FileName.AbgFiles + ";paris"
            'END IF 
            'FILE FileName.AbgFiles'fÅr FIELDINFO nîtig 
            '
            'fieldno% = FILEINFO (FileName.AbgFiles,1)
            'REDIM FieldNames$(fieldno%)
            'FILLARRAY FieldNames$,1
            '
            '
            ''Feld-Infos fÅr Zeitstatistik ermitteln ---------------
            '# Indizes
            'indexno% = FILEINFO (FileName.AbgFiles,0)
            ''# der TXT - Felder mit LÑnge > 1000
            'txt1000% = 0
            'FOR i% = 0 TO fieldno% - 1
            '    IF FIELDINFO$ (FieldNames$(i%),0) = "TXT" THEN 
            '
            '        IF VAL ( FIELDINFO$ (FieldNames$(i%),4)) > 1000 THEN 
            '           'CALL Fehler (FieldNames$(i%) + "." + FileName.AbgFiles,"")
            '            txt1000% = txt1000% + 1
            '        END IF 
            '    END IF 
            'NEXT i%
            '
            'SELECT CURRENT LOCK FILE "abgfiles" INDEX CodeFile.AbgFiles
            '    a$ = FileName.AbgFiles
            '    FieldCount.AbgFiles = fieldno%
            '    IndexCount.AbgFiles = indexno%
            '    TXT1000Count.AbgFiles = txt1000%
            '    'CALL Fehler (FileName.AbgFiles,"")
            'STORE FILE "abgfiles"
            'UNLOCK CURRENT FILE "abgfiles" 
 'IgnoreFile: 
            'ON ERROR 
            ''Ende:  Feld-Infos fÅr Zeitstatistik ermitteln --------------- 
 
    SELECT NEXT FILE "AbgFiles" INDEX CodeFile.AbgFiles
 WEND 
 
 z% = 0
 SELECT FIRST FILE "AbgDeps" INDEX CodeDep.AbgDeps
 WHILE NOT EOF ("AbgDeps")
    IF test.AbgDeps <> 2 THEN 
        ? "    Fehler in CodeDep = " + STR$ (CodeDep.AbgDeps,"z") + ": " + STR$ (test.AbgDeps - 2,"z")
    ELSE 
        z% = z% + 1
    END IF 
    
    SELECT NEXT FILE "AbgDeps" INDEX CodeDep.AbgDeps
 WEND 
 CALL Fehler("Ende Phase 2","")
 
  ? "AbgDeps enthaelt " + STR$ ( RECCOUNT ("AbgDeps"),"z") + " Master-Detail-Beziehungen, " + STR$ (z%,"z") + " davon sind ok."
 
 
 '3. öbergeordnete Files von Z und C und A mÅssen selbst Z oder C oder A sein
 
 ? " "
 ? "Phase 3 ----------------------"
 
 SELECT FIRST FILE "AbgFiles" INDEX CodeFile.AbgFiles
 WHILE NOT EOF ("AbgFiles")
 
    '--- Fieldcount fÅr Zeitmessung schreiben---
    IF FileName.AbgFiles <> "CONFIG" THEN 
        'CALL Fehler(FileName.AbgFiles,"")
        IF NOT OPEN (FileName.AbgFiles) THEN 
            OPEN FILE SHARE ,1path$ + Dir.AbgFiles + "\" + FileName.AbgFiles + ";paris"
        END IF 
       fieldno% = FILEINFO (FileName.AbgFiles,1)
  
        SELECT CURRENT LOCK FILE "AbgFiles" INDEX CodeFile.AbgFiles
            FieldCount.AbgFiles = fieldno%
        STORE FILE "AbgFiles"
        UNLOCK CURRENT FILE "AbgFiles"
 
        IF OPEN (FileName.AbgFiles) THEN CLOSE FILE FileName.AbgFiles
 
        IF Typ.AbgFiles = "Z" OR Typ.AbgFiles = "C" OR Typ.AbgFiles = "A" THEN 
    END IF 
    '--- Ende: Fieldcount fÅr Zeitmessung schreiben---
        
        'die aktuelle Code merken
        code% = CodeFile.AbgFiles
 
 
        'fÅr Fehlerausgabe
        filename$ = FileName.AbgFiles
        typ$ = Typ.AbgFiles
        ? filename$ + ": Typ = " + typ$
        'CALL Fehler(filename$,"")
        'Åbergeordnete durchlaufen, falls C oder Z
        SELECT FIRST FILE "AbgDeps" INDEX CodeFile.AbgDeps
        SELECT KEY code% FILE "AbgDeps" INDEX CodeFile.AbgDeps
        WHILE NOT EOF ("AbgDeps") AND CodeFile.AbgDeps = code%
            ? "    " + MainFile.AbgDeps + ": Typ = ";
            'CALL Fehler(MainFile.AbgDeps,"")
            'zum Åbergeordneten File (in AbgFiles) springen und auf Z oder C oder A prÅfen
            SELECT FIRST FILE "AbgFiles" INDEX CodeFile.AbgFiles
            SELECT KEY MainCodeFile.AbgDeps FILE "AbgFiles" INDEX CodeFile.AbgFiles
            IF FOUND ("AbgFiles") THEN 
                ? Typ.AbgFiles
                IF Typ.AbgFiles <> "Z" AND Typ.AbgFiles <> "C" AND Typ.AbgFiles <> "A" THEN 
                    ' nicht plausi. !!
                    a$ = "!!!! Datei " + filename$ + " ist vom Typ " + typ$
                    a$ = a$ + " und hat uebergeordnete Datei " + FileName.AbgFiles + " vom Typ " + Typ.AbgFiles + " !!!!"
                    ? a$
                END IF 
            ELSE 
                
                ? " ... nicht gefunden"
            END IF 
            SELECT NEXT FILE "AbgDeps" INDEX CodeFile.AbgDeps
        WEND 
 
        'und weiter bei code% 
        SELECT FIRST FILE "AbgFiles" INDEX CodeFile.AbgFiles
        SELECT KEY code% FILE "AbgFiles" INDEX CodeFile.AbgFiles
    END IF 
 
    SELECT NEXT FILE "AbgFiles" INDEX CodeFile.AbgFiles
 
 WEND 
  
 IF txtfile$ <> "" THEN 
    CLOSE OUTPUT 
 END IF 
 
 
 
 END SUB 
 '*********************************************************************************************** 
  

SUB CryptPwd(basepath$)
 
 'basepath$ ist (z.B.) der CODie-Pfad 
 ausgabe% = - 1
 DIM dir$(10)
 dir$(0) = basepath$
 dir$(1) = basepath$ + "OFFICE"
 dir$(2) = basepath$ + "PROVIS"
 dir$(3) = basepath$ + "ABGLEICH\SEND"
 dir$(4) = basepath$ + "ABGLEICH\LOAD"
 
 DIM files$(1000)
 IF ausgabe% = - 1 THEN CLS 
 
 
 dir% = 0
 'Åber alle Verzeichnisse
 WHILE dir$(dir%) <> ""
    ON ERROR GOTO NextDirErr
    IF NOT EXISTS (dir$(dir%)) THEN 
        REQUEST "Verzeichnis " + dir$(dir%) + " existiert nicht"
        GOTO NextDir
    END IF 
    DIRECTORY dir$(dir%)
    IF ausgabe% = - 1 THEN ? "----" + dir$(dir%) + "---"
    REDIM files$(1000)'Array leeren
    FILLARRAY files$,5,"*.SBf"
    datei% = 0
    'Åber alle Dateien im aktuellen Verzeichnis
    WHILE files$(datei%) <> ""
        ON ERROR GOTO NextFileErr
        IF NOT EXISTS (files$(datei%)) THEN 
            REQUEST "Datei " + files$(datei%)existiert nicht
            GOTO NextFile
        END IF 
        datei$ = MID$ (files$(datei%),1, LEN (files$(datei%)) - 4)'.sbf entfernen
        IF ausgabe% = - 1 THEN ? &11datei$;
        'Datei auf einen anderen Namen reorganisieren
        'sicherheitshalber vorher die Sperrdatei lîschen
        IF EXISTS (datei$ + ".sb!") THEN DELETE datei$ + ".sb!"
        OPEN FILE datei$ + ";paris"
        REORGANIZE FILE datei$ TO "gaga.sbf"
        OPEN FILE "gaga;paris"
        CLOSE FILE datei$
        DELETE datei$ + ".*"
 
        CREATE FILE datei$ + ";;;;paris" FROM FILE "gaga"
        CLOSE FILE "gaga"
        DELETE "gaga.*"
 
        IF ausgabe% = - 1 THEN ? "... Ok"
 
        'alles io
        GOTO NextFile
 
NextFileErr: 
        IF ausgabe% = - 1 THEN ? "FEHLER beim Reorganisieren von " + DIRECTORY + "\" + datei$
        ON ERROR 
NextFile:             
 
        datei% = datei% + 1
 
    WEND 
    'alles io
    GOTO NextDir
NextDirErr: 
    ON ERROR 
    REQUEST "Fehler beim Reorganisieren von " + DIRECTORY + "\" + datei$
NextDir: 
 
    dir% = dir% + 1
 
 WEND 
 
 
 END SUB 
 '***********************************************************************************************  
 

SUB CreatePPCSFile(datei$,path$)
 'FÅgt fÅr PPCS-Abgleich notwendige Felder hinzu
 'îffnet kurzzeitig die crfilepp.sbr (nutzt FldAddUpd)

     CALL ServerDown()
     CALL ServerInit()
     cfile$ = FILE 
     IF OPEN (datei$) THEN CLOSE FILE datei$

     CALL DFileUpd(2,path$ + datei$ + ";paris")
 
     FILE datei$

     CALL FldAddUpd("Workstation","NUM;00000000.",1)
     CALL FldAddUpd("CodeServer","NUM;00000000.",1)
     CALL FldAddUpd("TState","TXT;1",1)
     CALL FldAddUpd("Rec0","NUM;00000000.",1)
     CALL FldAddUpd("Rec1","NUM;00000000.",1)
     CALL FldAddUpd("Rec2","NUM;00000000.",1)
     CALL FldAddUpd("Rec3","NUM;00000000.",1)
     CALL FldAddUpd("Rec4","NUM;00000000.",1)
     CALL FldAddUpd("Rec5","NUM;00000000.",1)
     CALL FldAddUpd("Rec6","NUM;00000000.",1)
     CALL FldAddUpd("Rec7","NUM;00000000.",1)
     CALL FldAddUpd("Rec8","NUM;00000000.",1)
     CALL FldAddUpd("Rec9","NUM;00000000.",1)
     CALL FldAddUpd("Rec10","NUM;00000000.",1)
     CALL FldAddUpd("Rec11","NUM;00000000.",1)
     CALL FldAddUpd("Rec12","NUM;00000000.",1)
     CALL FldAddUpd("Rec13","NUM;00000000.",1)
     CALL FldAddUpd("Rec14","NUM;00000000.",1)
     CALL FldAddUpd("Rec15","NUM;00000000.",1)
     CALL FldAddUpd("Rec16","NUM;00000000.",1)
     CALL FldAddUpd("Rec17","NUM;00000000.",1)
     CALL FldAddUpd("Rec18","NUM;00000000.",1)
     CALL FldAddUpd("Rec19","NUM;00000000.",1)
     SAVE FILE FILE 
 
     FILE cfile$

 END SUB 
 '***********************************************************************************************

 
SUB DeleteWksData(wks%)
 'lîscht aus allen Dateien die DatensÑtze mit Workstation.file = wks%
 
 tempdir$ = DIRECTORY 
 
 DIM sbf$(1000)
 CLS 
 DIM dirs$(10)
 dirs$(0) = "d:\afm.her\provis"
 dirs$(1) = "d:\afm.her\office"
 dirs$(2) = "d:\afm.her"
 
 dir% = 0
 WHILE (dirs$(dir%) <> "")
    
    DIRECTORY dirs$(dir%)
    i%% = 0
    REDIM sbf$(1000)
    FILLARRAY sbf$,5,"*.SBf"
    WHILE sbf$(i%%) <> ""
        
          SET STATUS sbf$(i%%)
          ON ERROR GOTO Error2
          sbf$(i%%) = MID$ (sbf$(i%%),1, LEN (sbf$(i%%)) - 4)
          OPEN FILE sbf$(i%%) + ";paris"
 
          wksfield$ = "Workstation." + sbf$(i%%)
          ON ERROR GOTO FieldError
          SELECT FIRST FILE sbf$(i%%) INDEX wksfield$$
          SELECT KEY wks% FILE sbf$(i%%) INDEX wksfield$$
          WHILE NOT EOF (sbf$(i%%)) AND wksfield$$ = wks%
               
               SELECT CURRENT LOCK FILE sbf$(i%%)
               SELECT REMOVE FILE sbf$(i%%)
 
               'SELECT NEXT FILE sbf$(i%%) INDEX wksfield$$
          WEND 
 
          CLOSE FILE sbf$(i%%)
          GOTO Next2
 
FieldError: 
          'Feld Workstation wahrscheinlich nicht vorhanden ==> nÑchste Datei
          GOTO Next2
Error2: 
        REQUEST "Fehler bei Bearbeitung von Datei " + sbf$(i%%),"",2
        ON ERROR 
Next2: 
     i%% = i%% + 1
 
    WEND 
    
    dir% = dir% + 1
 
 WEND 
 
 END SUB 
 '***********************************************************************************************  
 

SUB FilialeToCenter(BaseDir$,wks%,OCenterFiliale%)
 'wandelt ein Verzeichnis mit Filial-Daten in eine Zentrale um
 '
 'wenn wks% >= 0  ==> die Abgleichs-Daten (Typ A, Y - also Adressen, Telefon, ...) verbleiben 
 '                    und werden der Filiale wks% zugeordnet (Workstation=wks%)
 '                ==> Spezialfall:  wenn wks% = 0 und OCenterFiliale% = -1 wird die Filiale also komplett
 '                    in eine Zentrale umgewandelt
 '                    
 '  - OCenterFiliale% = -1 ==> AY-Daten werden nicht gelîscht ==> OnlineCenterFiliale wird erzeugt
 '    Problem: wie bekommt man die Mitarbeiter in die Zentrale?
 '
 'wenn wks% = -1  ==> es wird eine Zentrale erstellt mit zentralen Daten (GEADR, SPARTEN, ...)
 '                    die von der Filiale Åbernommen werden und also so behandelt werden, als wÑhren sie
 '                    von zentralen Mitarbeitern erfa·t worden
 '                    lokale Daten werden gelîscht
 '                    Abgleichs - Daten werden gelîscht
 '
 'OCenterFiliale% = 0 ==> AY-Daten werden gelîscht
 '                    
 'Z-Daten werden gelîscht, wenn OCenterFiliale% = -1 AND wks% > 0
 
 
 'Vorgang
 '  * alle Daten auf Workstation = 0 bringen; 
 '      wenn wks% gesetzt = = > Typ-A,Y-Dateien erhalten Workstation = wks%
 '  * Sonderbehandlung fÅr bestimmte Dateien im SELECT CASE - Block mîglich
 '  
 'Vor.: AbgFiles mu· geîffnet sein
 '  
 '
 'Sinn machen folgende (wks%,OCenterFiliale%)-Paare:
 '  - (0,-1)    komplette Zentrale aus Filiale erstellen
 '  - (0, 0)    Zentrale Daten einer Filiale Åbernehmen
 '  - (>0, -1)  normale Filiale in OnlineCenter-Filiale umwandeln (Problem: CZ-Dateien)
 '  - (>0, 0)   eine leere Filiale aus einem Zentral-Pfad erzeugen
 '  - (-1, x)   nur bedingt sinnvoll ...

 ERASE jaFileTyp$,jaFileCode$
 GLOBAL jaFileTyp$,jaFileCode$

 IF NOT OPEN ("abgfiles") THEN OPEN FILE BaseDir$ + "AbgFiles;paris"

 tempdir$ = DIRECTORY 
 
 DIM sbf$(1000)
 DIM dirs$(10)
 dirs$(0) = BaseDir$ + "provis\"
 dirs$(1) = BaseDir$ + "office\"
 dirs$(2) = BaseDir$

 
 dir% = 0
 WHILE (dirs$(dir%) <> "")
    ON ERROR GOTO FTCDirError
    dir$ = dirs$(dir%)
    DIRECTORY dir$
    i%% = 0
    REDIM sbf$(1000)
    FILLARRAY sbf$,5,"*.SBf"
    WHILE sbf$(i%%) <> ""
        ErrorNo% = 0
        ON ERROR GOTO FTCFileError 
        sbf$(i%%) = MID$ (sbf$(i%%),1, LEN (sbf$(i%%)) - 4)
        datei$ = UCASE$ (sbf$(i%%))
        
        
        SELECT CASE datei$

        CASE "ABGFILES"
            'gar nix tun
            datei$ = ""'schlie·en verhindern
             
        CASE "CONFIG","REDRU","STATIST","STATIST2","ABGDEPS"
            '??
        
        CASE ELSE 'Normalfall: AbgFiles nutzen
            IF OPEN (datei$) THEN CLOSE FILE datei$
            OPEN FILE dir$ + datei$ + ";paris"

            CALL GetFileInfo(datei$)
            IF jaFileTyp$ = "" OR jaFileTyp$ = "I" THEN 
                IF wks% = - 1 THEN 
                    REMOVE FROM FILE datei$
                ELSE 
                    'lokale Daten erzeugen
                    ErrorNo% = ChangeWksData%(datei$, - 1,wks%)
                    IF ErrorNo% <> - 1 THEN 
                        'Fehlerausgabe
                        GOTO FTCFileError
                    END IF 
                END IF 
            END IF 

            IF jaFileTyp$ = "A" OR jaFileTyp$ = "Y" OR jaFileTyp$ = "C" THEN 
                'Daten der Filiale mit Workstation=wks%, die bereits in der Zentrale liegen 
                IF OCenterFiliale% = 0 OR wks% = - 1 THEN 
                    REMOVE FROM FILE datei$
                ELSE 
                    ErrorNo% = ChangeWksData%(datei$, - 1,wks%)
                    IF ErrorNo% <> - 1 THEN 
                        'Fehlerausgabe
                        GOTO FTCNextError
                    END IF 
                END IF 

            END IF 

            IF jaFileTyp$ = "Z" THEN 
                'Zentrale Daten erzeugen (Workstation = 0) oder lîschen
                                
                IF wks% > 0 AND OCenterFiliale% = 0 THEN 
                    REMOVE FROM FILE datei$
                ELSE 
                    ErrorNo% = ChangeWksData%(datei$, - 1,0)' Daten in Workstation = 0 umwandeln
    
                    IF ErrorNo% <> - 1 THEN 
                        'Fehlerausgabe
                        GOTO FTCNextError
                    END IF 
                END IF 
            END IF 

            SELECT CASE datei$
                CASE "MAADR"
                    'Workstation von Mitarbeiter <ohne Zuordnung> auf 0 setzen
            END CASE 
        END CASE 
        'alles io
        ? datei$ + ": Ok"
        IF OPEN (datei$) THEN CLOSE FILE datei$
        GOTO FTCNextFile
FTCFileError: 
    ? datei$ + ": " + ERR$ ( ERRNO )
    GOTO FTCNextFile

FTCNextFile: 
        
        ON ERROR GOTO FTCDirError
        i%% = i%% + 1
    WEND 

FTCDirError: 
    ? datei$ + ": " + ERR$ ( ERRNO )
    GOTO FTCDirNext

FTCDirNext: 
    ON ERROR 
    ? "---- " + dir$ + " ---"
    dir% = dir% + 1
 WEND 

 
 END SUB 
 '*********************************************************************************************** 
 
 
SUB CenterToFiliale(BaseDir$,wks%,CopyData%)

 'erzeugt aus einem Center-Pfad eine leere Online-Center-Filiale
 'öbergabe:
 '  - "CODie-Pfad" der Zentrale
 '  - Nummer der kÅnftigen Workstation
 
 'Vorgang: 
 '  * in allen lokalen Dateien die Workstation setzen
 '  * die Load/Send-Dateien erzeugen
 '  * die Signatur in die INI-Datei schreiben  

    CALL FilialeToCenter(BaseDir$,wks%,0)

    IF NOT EXISTS (BaseDir$ + "Abgleich") THEN 
        MAKE DIRECTORY BaseDir$ + "Abgleich"
    END IF 
    IF NOT EXISTS (BaseDir$ + "Abgleich\Load") THEN 
        MAKE DIRECTORY BaseDir$ + "Abgleich\Load"
    END IF 
    IF NOT EXISTS (BaseDir$ + "Abgleich\Send") THEN 
        MAKE DIRECTORY BaseDir$ + "Abgleich\Send"
    END IF 
    IF NOT EXISTS (BaseDir$ + "Abgleich\Log") THEN 
        MAKE DIRECTORY BaseDir$ + "Abgleich\Log"
    END IF 

    ERASE _localpath$
    GLOBAL _localpath$
    _localpath$ = BaseDir$

    IF NOT OPEN ("abgfiles") THEN OPEN FILE BaseDir$ + "AbgFiles;paris"
    SELECT FIRST FILE "AbgFiles" INDEX CodeFile.AbgFiles
    WHILE NOT EOF ("AbgFiles")

        SELECT CASE UCASE$ (Typ.AbgFiles)
            CASE "C","Z","A","Y"
                CALL CreateLoadSend(FileName.AbgFiles, - 1)
                
        END SELECT 

        SELECT NEXT FILE "AbgFiles" INDEX CodeFile.AbgFiles
    WEND 
    
    ON ERROR GOTO CTFRegisterOk
    REGISTER CLEAR "WritePrivateProfileString"
CTFRegisterOk: 
    REGISTER "Kernel","WritePrivateProfileString","ICCCC"

    
    ON ERROR GOTO CTFRegisterOk2
    REGISTER CLEAR "_GetStringHash"
CTFRegisterOk2: 
    REGISTER "CODieLIB.dll","_GetStringHash","ICCF"

    a% = CALL ("WritePrivateProfileString","PROVIS","Workstation", STR$ (wks%,"z"),_localpath$ + "CODIEAPP.NET")
    a% = CALL ("_GetStringHash", STR$ (wks%,"z"),"paris",sig$)
    a% = CALL ("WritePrivateProfileString","PROVIS","WorkstationSig",sig$,_localpath$ + "CODIEAPP.NET")
  
 END SUB 
 '***********************************************************************************************
  
 
FUNCTION ChangeWksData%(datei$,oldwks%,newwks%)
 'wandelt alle DatensÑtze mit Workstation = oldwks% in newwks% um
 '
 'wenn oldwks% = -1 ==> fÅr alle DatensÑtze Workstation = newwks% setzen
 '           sonst  ==> nur DatensÑtze mit Workstation = oldwks% in Workstation = newwks% umwandeln
 'Vor.: datei$ mu· geîffnet sein 

 'RÅckgabe von -1 wenn alles io, sonst ERRNO
 '
 'kann vielleicht spÑter mal fÅr das VerÑndern von BÅro-Strukturen verwendet werden ?!
 
 ON ERROR GOTO CWDError
 ChangeWksData% = - 1
 wksfield$ = "Workstation." + datei$
 
 IF oldwks% = - 1 THEN 
 
    UPDATE wksfield$$ = newwks%
    END UPDATE 
 ELSE 
    UPDATE wksfield$$ = newwks% WHERE wksfield$$ = oldwks%
    END UPDATE 
 END IF 
 'alles io
 GOTO CWDOk:

CWDError: 
    ChangeWksData% = ERRNO 
CWDOk: 
 
 END FUNCTION 
 '***********************************************************************************************  

 
 
SUB KonRepair(path$,mainFile$,mainField$,testFile$,testField$,testCode$)
 
     'prÅft fÅr die aktuelle Datei, ob Werte in _testField$ existieren, die
     'nicht in _mainFile$ im Feld _mainField$ existieren
     '_testCode$ ist das Code-Feld der aktuellen Datei
     'wenn gefunden: auf <ohne Zuordnung>-Datensatz im MainFile (ZweiMille%) verweisen
     IF NOT OPEN (mainFile$) THEN 
          OPEN FILE SHARE ,1path$ + mainFile$ + ";paris"
          hasOpen% = - 1' ==> Datei am Ende wieder schlie·en
     END IF 
 
     mainField$ = mainField$ + "." + mainFile$
    
     zeroCode% = - 1
    
     testCode$ = testCode$ + "." + testFile$
     testField$ = testField$ + "." + testFile$
     testFile$ = UCASE$ (testFile$)
     SELECT FIRST FILE testFile$ INDEX testCode$$
     WHILE NOT EOF (testFile$)
          IF (testField$$ < 1) OR ( NOT EXISTS (testField$$,mainField$$)) THEN 
 
               'IF jaDebug% = - 1 THEN CALL Fehler("Inkonsistenz (KonRepair)",testFile$)
 
               SELECT CURRENT LOCK FILE testFile$ INDEX testCode$$
               testField$$ = ZweiMille%
               STORE FILE testFile$
               UNLOCK CURRENT FILE testFile$
 
          END IF 
          SELECT NEXT FILE testFile$ INDEX testCode$$
     WEND 
     IF hasOpen% = - 1 THEN 
          CLOSE FILE mainFile$
     END IF 
     'CALL Fehler("","")
 END SUB 
 '*************************************************************************
 
 
SUB KonDelete(path$,mainFile$,mainField$,testFile$,testField$,testCode$)
 
    'prÅft fÅr die aktuelle Datei, ob Werte in _testField$ existieren, die
    'nicht in _mainFile$ im Feld _mainField$ existieren
    '_testCode$ ist das Code-Feld der aktuellen Datei
    'wenn gefunden ==> rabiat lîschen
     
     IF NOT OPEN (mainFile$) THEN 
          OPEN FILE SHARE ,1path$ + mainFile$ + ";paris"
          hasOpen% = - 1
     END IF 
     mainField$ = mainField$ + "." + mainFile$
     testCode$ = testCode$ + "." + testFile$
     testField$ = testField$ + "." + testFile$
 
     SELECT FIRST FILE testFile$ INDEX testCode$$
     WHILE NOT EOF (testFile$)
          IF NOT EXISTS (testField$$,mainField$$) THEN 
               'IF jaDebug% = - 1 THEN CALL Fehler("Inkonsistenz (KonDelete)",testFile$)
               SELECT CURRENT LOCK FILE testFile$ INDEX testCode$$
               SELECT REMOVE FILE testFile$
          ELSE 
               SELECT NEXT FILE testFile$ INDEX testCode$$
          END IF 
     WEND 
     IF hasOpen% = - 1 THEN 
          CLOSE FILE mainFile$
     END IF 
 END SUB 
 '*************************************************************************
 
 
SUB KonKvertrag(basepath$)
     'sucht nach VertrÑgen ohne Adresse und erzeugt diese gegebenenfalls aus
     'den rudimentÑren Adre·-Angaben in der KVERTRAG.sbf
     REM CALL Fehler("KonKvertrag","")
     IF NOT OPEN ("ADRESSEN") THEN OPEN FILE SHARE ,1basepath$ + "\office\Adressen;paris"
     zerocode% = - 1
     SELECT FIRST FILE "kvertrag" INDEX lfdnr.kvertrag
     WHILE NOT EOF ("kvertrag")
          IF NOT EXISTS (CodeKu.Kvertrag,CodeKu.Adressen) THEN 
 
               IF jaDebug% = - 1 THEN CALL Fehler("Vertrag ohne Adresse","")
 
               codekuneu$ = SER1 ("codeku","adressen")
               BLANK FILE "adressen"
                    CodeKu.Adressen = codekuneu$
                    CodeMa.Adressen = ZweiMille$
                    Workstation.Adressen = Workstation%
                    Nachname.Adressen = ANachname.Kvertrag
                    Vorname.Adressen = AVorname.Kvertrag
                    AOrt.Adressen = AOrt.Kvertrag
                    APLZ.Adressen = APLZ.Kvertrag
                    AStra·e.Adressen = AStrasse.Kvertrag
               STORE FILE "adressen"
 
               SELECT CURRENT LOCK FILE "kvertrag" INDEX lfdnr.kvertrag
               CodeKu.Kvertrag = codekuneu$
               STORE FILE "kvertrag"
               UNLOCK CURRENT FILE "kvertrag"
          END IF 
          SELECT NEXT FILE "kvertrag" INDEX lfdnr.Kvertrag
     WEND 
     CLOSE FILE "adressen"
 END SUB 
 '*************************************************************************
 
 
SUB CreateLoadSend(sfile$,removeData%)
    'Erzeugt die zu einer Datei gehîrigen Load- und Send-Dateien
    'Informationen Åber die Namen der Load/Send-Dateien werden aus AbgFiles.sbf
    'entnommen    
    'sfile$: Name der Quelldatei (ohne .sbf)
    'removeData%: -1 ==> den Inhalt der Load/Send-Dateien lîschen ?
    'Vor.: AbgFiles offen, _localpath$ definiert
 
    SELECT FIRST FILE "AbgFiles" INDEX FileName.AbgFiles
    SELECT KEY sfile$ FILE "AbgFiles" INDEX FileName.AbgFiles
    IF NOT FOUND ("AbgFiles") THEN 
        IF jaDebug% = - 1 THEN CALL Fehler("Load/Send-Dateien konnten nicht erstellt werden:",sfile$)
        END SUB 
    END IF 
    
    loadfile$ = Prefix.AbgFiles + "Load"
    sendfile$ = Prefix.AbgFiles + "Send"
    typ$ = Typ.AbgFiles
 
    IF OPEN (sendfile$) THEN 
        CLOSE FILE sendfile$
    END IF 
    IF EXISTS (_localpath$ + "ABGLEICH\Send\" + sendfile$ + ".SBF") THEN 
        DELETE _localpath$ + "ABGLEICH\Send\" + sendfile$ + ".*"
    END IF 
 
    IF OPEN (loadfile$) THEN 
        CLOSE FILE loadfile$
    END IF 
 
    IF EXISTS (_localpath$ + "ABGLEICH\Load\" + loadfile$ + ".SBF") THEN 
        DELETE _localpath$ + "ABGLEICH\Load\" + loadfile$ + ".*"
    END IF 
 
    IF NOT OPEN (sfile$) THEN 
        OPEN FILE _localpath$ + Dir.Abgfiles + "\" + sfile$ + ";paris"
    END IF 

    REORGANIZE FILE sfile$ TO _localpath$ + "ABGLEICH\Send\" + sendfile$ + ".SBF"
    IF removeData% = - 1 THEN 
        REMOVE FROM FILE sendfile$
    END IF 
    CLOSE FILE sendfile$
    COPY _localpath$ + "ABGLEICH\Send\" + sendfile$ + ".*" TO _localpath$ + "ABGLEICH\Load"
    IF EXISTS (_localpath$ + "ABGLEICH\Load\" + sendfile$ + ".sb!") THEN 
        DELETE _localpath$ + "ABGLEICH\Load\" + sendfile$ + ".sb!"
    END IF 
    OPEN FILE _localpath$ + "ABGLEICH\Load\" + sendfile$ + ";paris"
    REMOVE FROM FILE sendfile$
    REORGANIZE FILE sendfile$ TO _localpath$ + "ABGLEICH\Load\" + loadfile$ + ".SBF"
    CLOSE FILE loadfile$
    REMOVE FILE sendfile$
 
 END SUB 
 '*************************************************************************
 
 
SUB CrOhneZuord()
 'erzeugt <ohne Zuordnung>-DatensÑtze mit code = ZweiMille%
 
     path$ = _netpath$ + "PROVIS\"
 
     CALL DFileUpd(2,path$ + "MAADR;paris")
     IF ZweiMille% > 0 THEN 
          'PPCS-Version
          IF EXISTS (0,CodeMa.Maadr) THEN 
 
               '<ohne Zuordnung> ex. bereits ==> jetzt zentrale Code verpassen
               SELECT FIRST FILE "Maadr" INDEX CodeMa
               SELECT KEY 0 FILE "Maadr" INDEX CodeMa
               SELECT CURRENT LOCK FILE "Maadr"
                    CodeMa.Maadr = ZweiMille%
                    Workstation.Maadr = 0
                    CodeServer = ZweiMille%
               STORE FILE "Maadr"
               UNLOCK CURRENT FILE "Maadr"
          END IF 
 
          IF NOT EXISTS (ZweiMille%,CodeMa.MAADR) THEN 
               BLANK FILE "Maadr"
                    CodeMa.Maadr = ZweiMille%
                    Nachname.Maadr = "<ohne Zuordnung>"
                    CodeServer = ZweiMille%
               STORE FILE "Maadr"
          END IF 
 
     ELSE 
          'Normale Programm-Version
          IF NOT EXISTS (0,CodeMa.MAADR) THEN 
               BLANK FILE "Maadr"
                    CodeMa.Maadr = 0
                    Nachname.Maadr = "<ohne Zuordnung>"
                    CodeServer = 0
               STORE FILE "Maadr"
          END IF 
     END IF 
     
     'CALL DFileUpd(2,path$ + "SPGRUPPE;paris") 
     'u.s.w. ... SPGRUPPE, GEADR, SPARTEN, VPRODUKT, TARIF, AKTIONEN, SUPERVIS
 
 END SUB 
 '************************************************************************* 
 
 
SUB PPCSFldUpdate()
 'fÅgt PPCS-spezifische Felder zur aktuellen Datei hinzu
 'Vor.: Datei offen und auf FILE gesetzt
 
     IF ZweiMille% = 0 THEN END SUB 
 
     typ$ = GetFileTyp$( FILE )
     IF typ$ = "Z" OR typ$ = "C" OR typ$ = "Y" OR typ$ = "D" OR typ$ = "A" THEN 
     ELSE 
          END SUB 'keine Datei, die in den Abgleich involviert ist 
     END IF 
 
     CALL FldAddUpd("CodeServer","NUM;00000000.",1)
     CALL FldAddUpd("TState","TXT;1",1)
     CALL FldAddUpd("Rec0","NUM;00000000.",1)
     CALL FldAddUpd("Rec1","NUM;00000000.",1)
     CALL FldAddUpd("Rec2","NUM;00000000.",1)
     CALL FldAddUpd("Rec3","NUM;00000000.",1)
     CALL FldAddUpd("Rec4","NUM;00000000.",1)
     CALL FldAddUpd("Rec5","NUM;00000000.",1)
     CALL FldAddUpd("Rec6","NUM;00000000.",1)
     CALL FldAddUpd("Rec7","NUM;00000000.",1)
     CALL FldAddUpd("Rec8","NUM;00000000.",1)
     CALL FldAddUpd("Rec9","NUM;00000000.",1)
     CALL FldAddUpd("Rec10","NUM;00000000.",1)
     CALL FldAddUpd("Rec11","NUM;00000000.",1)
     CALL FldAddUpd("Rec12","NUM;00000000.",1)
     CALL FldAddUpd("Rec13","NUM;00000000.",1)
     CALL FldAddUpd("Rec14","NUM;00000000.",1)
     CALL FldAddUpd("Rec15","NUM;00000000.",1)
     CALL FldAddUpd("Rec16","NUM;00000000.",1)
     CALL FldAddUpd("Rec17","NUM;00000000.",1)
     CALL FldAddUpd("Rec18","NUM;00000000.",1)
     CALL FldAddUpd("Rec19","NUM;00000000.",1)
 
     'SAVE FILE FILE 
 
 END SUB 
 '************************************************************************* 
 
SUB PPCSUpdate()
 'Update, fÅr PPCS-Version
 'Voraussetzung: Datei offen und auf FILE gesetzt
     cfile$ = FILE 
     'CALL Fehler("","")
     IF ZweiMille% < 0 THEN 
          GOTO PPCSUpdateEnd 
     END IF 
 
     CALL GetFileInfo( FILE )
  
     IF jaFileTyp$ = "Z" OR jaFileTyp$ = "C" OR jaFileTyp$ = "Y" OR jaFileTyp$ = "D" OR jaFileTyp$ = "A" THEN 
     
     ELSE 
          'keine Datei, die in den Abgleich involviert ist 
          GOTO PPCSUpdateEnd
     END IF 
 
     'sis:
     IF jaFileCode$ = "" THEN 
          REQUEST "Fehler: FileCode konnte nicht ermittelt werden", FILE 
          GOTO PPCSUpdateEnd
          END SUB 
     END IF 
     SET STATUS "PPCS - Felder hinzufÅgen"
     CALL FldAddUpd("CodeServer","NUM;00000000.",1)
     CALL FldAddUpd("TState","TXT;1",1)
     CALL FldAddUpd("Rec0","NUM;00000000.",1)
     CALL FldAddUpd("Rec1","NUM;00000000.",1)
     CALL FldAddUpd("Rec2","NUM;00000000.",1)
     CALL FldAddUpd("Rec3","NUM;00000000.",1)
     CALL FldAddUpd("Rec4","NUM;00000000.",1)
     CALL FldAddUpd("Rec5","NUM;00000000.",1)
     CALL FldAddUpd("Rec6","NUM;00000000.",1)
     CALL FldAddUpd("Rec7","NUM;00000000.",1)
     CALL FldAddUpd("Rec8","NUM;00000000.",1)
     CALL FldAddUpd("Rec9","NUM;00000000.",1)
     CALL FldAddUpd("Rec10","NUM;00000000.",1)
     CALL FldAddUpd("Rec11","NUM;00000000.",1)
     CALL FldAddUpd("Rec12","NUM;00000000.",1)
     CALL FldAddUpd("Rec13","NUM;00000000.",1)
     CALL FldAddUpd("Rec14","NUM;00000000.",1)
     CALL FldAddUpd("Rec15","NUM;00000000.",1)
     CALL FldAddUpd("Rec16","NUM;00000000.",1)
     CALL FldAddUpd("Rec17","NUM;00000000.",1)
     CALL FldAddUpd("Rec18","NUM;00000000.",1)
     CALL FldAddUpd("Rec19","NUM;00000000.",1)
 
     SET STATUS "PPCS-Update"
     UPDATE workstation = Workstation%
          Rec0 = 10000000 + Workstation%
          Rec1 = 10000000 + Workstation%
          Rec2 = 10000000 + Workstation%
          Rec3 = 10000000 + Workstation%
          Rec4 = 10000000 + Workstation%
          Rec5 = 10000000 + Workstation%
          Rec6 = 10000000 + Workstation%
          Rec7 = 10000000 + Workstation%
          Rec8 = 10000000 + Workstation%
          Rec9 = 10000000 + Workstation%
          Rec10 = 10000000 + Workstation%
          Rec11 = 10000000 + Workstation%
          Rec12 = 10000000 + Workstation%
          Rec13 = 10000000 + Workstation%
          Rec14 = 10000000 + Workstation%
          Rec15 = 10000000 + Workstation%
          Rec16 = 10000000 + Workstation%
          Rec17 = 10000000 + Workstation%
          Rec18 = 10000000 + Workstation%
          Rec19 = 10000000 + Workstation%
     END UPDATE 
      
     SET STATUS "Erzeugen Load/Send-Dateien"
     IF jaFileTyp$ = "Y" OR jaFileTyp$ = "A" THEN 
        CALL CreateLoadSend( FILE )
     END IF 
 
PPCSUpdateEnd: 
    FILE cfile$
    SAVE FILE FILE 
    dir$ = DIRECTORY 
    REM CALL Fehler(dir$ + "\" + FILE + ".sbf","Reorg")
    REORGANIZE FILE FILE TO dir$ + "\" + FILE + ".sbf"
 END SUB 
 
 '*************************************************************************   
FUNCTION CheckWksHash%()
 'PrÅft die Checksumme der Workstation
 'benutzt fÅr Filiale offline (in AbgleichInit())
 ' -1, wenn öbereinstimmung, sonst 0
 'Workstation mu· bereits eingelesen Worden sein
 'berechneter hash-Wert wird in calcSig$ geschrieben
    ON ERROR GOTO ErrorHandler
    CheckWksHash% = 0
    sig$ = ReadConfig$("PROVIS","WorkstationSig")
    magic$ = "paris"'oder was auch immer ...
    a% = CALL ("_GetStringHash", STR$ (Workstation%,"z"),magic$,calcSig$)
    IF calcSig$ = sig$ THEN 
        CheckWksHash% = - 1
    ELSE 
        IF jaDebug% = - 1 THEN CALL Fehler ("UngÅliger Eintrag fÅr 'Workstation' in codieapp.net","")
    END IF 
 
 END FUNCTION 

